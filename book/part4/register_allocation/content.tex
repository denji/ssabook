% vim:spell:spelllang=en
\chapter{Register Allocation\Author{F. Bouchez, S. Hack}}

{

\numberofpages{15}
Page count: 15


\def\ac#1{#1}
\def\dom{\preceq}
\def\ssa{SSA\xspace}


\chapterauthor{Bouchez, Hack}

{\it
We will start by giving an overview and intuitive understanding why SSA helps 
register allocation. Then we present the sub-problems of spilling and 
coloring/coalescing, as two separate phases, under the light of SSA. Finally, 
practical issues like register constraints and critical edge splitting are 
discussed.

%% Intro by Hack
%We will start by giving an overview and intuitive understanding why SSA helps register allocation.
%Then, we present the principal architecture of an SSA-based register allocator.

%We discuss spilling, assignment, and coalescing in further detail and review the proposed techniques.
%Finally, we present the corresponding complexity results for each phase.
}


The goal of register allocation is to map the variables of a program to 
physical memory locations. The compiler must indeed decide, in advance, in 
which locations will be held the values necessary for the computations of the 
program, and so for each instruction of the program. Registers are a very fast 
memory, hence are preferred for holding these values directly needed by the 
CPU. But there is a limited, small number of registers available in a 
processor, for instance only 8 registers for the IA-32 architecture (X86, 32 
bits), or 64 for the ST200, a Very Long Instruction Word (VLIW) processor.  On 
the other hand, in the initial program representation and until very late in 
the compiler back-end, values are stored in variables or temporaries, which are 
unbounded in number.



\section{Why does SSA help register allocation?}


\subsection{Classical register allocation}

\begin{itemize}
  \item based on graph coloring, linear scan
  \item spilling \& coloring are dependent
  \item heuristics are used to find a working solution
  \item avoiding spills is more important than coalescing
  \item Fab: It is important to outline that with decoupled reg-alloc, spilling and coloring become much simpler and more efficient.
\end{itemize}


\subsection{Programs under SSA have chordal interference graphs}
{\it 
\begin{itemize}
  \item Proof programs under SSA are chordal. Fab: I prefer not to have any 
    proofs.
  \item What difference does it make? Knowing the minimum number of colors is 
    easy: we know if spilling is mandatory or not
  \item why are the graphs chordal? View of SSA variables as subtrees of the 
    dominance tree; made possible because of \phifuns
  \item \phifuns allows colors to be ``re-arranged'' on incoming edges: this 
    is implicit shuffle code. For this to work, remember that semantics of 
    \phifun is they are \emph{parallel copies}. Hence, the SSA-variables of 
    same initial variable in different branches of dominance tree are 
    color-independent.

  \item Fab: the chordality and the parallel semantic of phi have already been considered in the first chapters of parts I (which does not mean that you cannot recall it).

\end{itemize}
}

It is known since 2005 that, under SSA, the interference graph of a program is 
chordal \cite{Brisk05,Pereira05:chordal,Hack06}.  Note that the interference 
graph depends on the interference notion, and we need that two variables alive 
at the same interfere even if they have the same value.\footnote{Note that, under 
SSA, there is only one definition, hence, if variable $b$ is defined as $b\gets 
a$, it is possible to replace every occurrence of $b$ by $a$ since they will 
always be equal.
%Note that this is akin to aggressive coalescing but is safe to 
%do under  \ssa as it will not increase the coloring number.  Constant 
%propagation can do this efficiently in a first pass, then it is not worth 
%considering the interference definition of Chaitin 
%(Definition~\ref{def:chaitin-interf}) as there is no remaining copy in the 
%program.
}



\begin{theorem}
  \label{thm:ssa-chordal}
  The interference graph~$G$ of a program under \ac{SSA} with dominance property is chordal.
  \index{dominance|exampleidx}
\end{theorem}


It is possible to give a more direct proof, without using the characterization 
of chordal graphs as the intersection graph of subtrees of a tree. It was by 
finding this proof that we first realized that the interference graph of a 
program under \ac{SSA} is chordal, which is the very first contribution of this 
thesis.  Then, we figured out that the chordal representation as subtrees of a 
tree would perfectly match the live-ranges under \ac{SSA}.

\begin{proof}
  Let $G$ be an interference graph of a program under \ac{SSA}.
  Let us define the following orientation of the 
  edges: if $def(u) \dom def(v)$, then $u \rightarrow v$.
  Property~\ref{prop:a-interf-b} states that every edge is directed.
%
  Consider a cycle $C$ of length at least $4$ in $G$, if there is one.  From 
  Theorem~\ref{thm:dom-partial-order}, the dominance relation is a partial 
  order: $C$~cannot form a directed cycle, thus there are two edges $u 
  \rightarrow v$ and $v \leftarrow w$, directed from~$u$ to~$v$ and from $w$ 
  to~$v$, i.e., the definitions of $u$ and of $w$ dominate the definition of 
  $v$.
%
  Since $u$ and $v$ interfere, and $u\rightarrow v$, $u$ is alive at $def(v)$ 
  and the same is true for $w$. $u$ and $w$ are both alive at the $def(v)$,
  they interfere and there is an edge between $u$ and $w$ in the graph, i.e., a 
  chord in~$C$.

%  Property~\ref{prop:st-dominent-u} states that either the definition of $u$ 
%  dominates the definition of $w$ or the converse, hence there is an edge 
%  between $u$ and $w$ in the graph, i.e., a chord in $C$.
\end{proof}


\subsubsection{Why so chordal?}

There is another, shorter proof that SSA interference graphs are chordal, 
although it uses more advanced graph theory. This proof shows however very well 
why these graphs are chordal.

\begin{proof}[Short proof]
  Corollary~\ref{cor:ssa-subtrees} states that under \ac{SSA}, live-ranges 
  are subtrees of the dominance graph. Hence the interference graph is the 
  intersection graph of a family of subtrees (the live-ranges) of a tree (the 
  dominance tree), which is another characterization of chordal graphs 
  \cite[Thm.~4.8]{Golumbic}.
\end{proof}



\subsection{Maxlive and colorability of graphs}
\begin{itemize}
  \item definition of Maxlive
  \item show that Maxlive is the minimum number of colors required
  \item scan of the dominance tree sufficient to know Maxlive: pseudo-code
  \item Fab: MAXLIVE minimum if interference graph==intersection graph. Clearly we do not want to go into such details but be careful to use precise and correct terms.

\end{itemize}
    


\section{The problem of spilling}

\subsection{Lowering Maxlive}
\begin{itemize}
  \item The min number of colors is Maxlive. Variables must be stored in memory 
    to lower the register pressure at points where it is $>R$.
  \item Whenever, Maxlive $\leq R$, we know for sure that spilling more in 
    unnecessary.
  \item Fab: if MAXLIVE<=R spilling is unecessary under some conditions (we color SSA code, going out of SSA code might require some additionnal spilling. Also without naming constraints). So again be careful about what you say. I think that the idea is to have a register allocator under SSA as simple as possible with a very simple modeling and nice properties. Then we cope with real world issues during the colored-SSA destruction.


\end{itemize}

\subsection{SSA does not help for spilling}
\begin{itemize}
  \item easy spill method: spill everywhere
  \item SSA split points are good for coloring, but not really for spilling 
    (see article spill everywhere under SSA)
  \item other split points to avoid spill everywhere are probably better
  \item Fab: if you need an example to illustrate that SSA does not really help in practice for spilling ask Quentin. It does help a little bit (dynamic programming possible for spill everywhere with few registers; further first can be generalized). But what you want to point it here is the fact that the disadvantages seem more important than advantages.
  \item Fab: the LCTES spill everywhere article does not discuss practical issues (such as the fact that it might insert a load or a store inside a loop...). It is more algorithmical issues.


\end{itemize}


\subsection{Spilling under SSA}
Still, we give a possibility to perform spilling under SSA
\begin{itemize}
  \item Hack's algorithm: simplified version?
  \item \`a la Belady following dominance tree?

  \item Fab: The last Algorithm from Sebastian is Belady like. So yes try to simplify it, provide the pseudo code and give the intuitions on how the full version improves it.

\end{itemize}



\section{Coloring and coalescing}
\subsection{Chordal property for coloring}
\begin{itemize}
  \item two simplicial nodes
  \item color in the reverse order of simplification
  \item one such order considers subtrees from the root of the tree
  \item no need to construct interference graph
  \item Fab: make it as more intuitive as possible. Avoid as much as possible chordal stuffs which are useless. Greedy coloring and its relationship with the subtree representation is important on the other hand. See with Philip to avoid redundancies between your chapter and his (SSA properties). It is important to outline here that this property that is due to decoupled+SSA enables more aggressive coalescing heuristics. But also simpler (tree-scan).
\end{itemize}

\subsection{Fast tree-scan solution}
\begin{itemize}
  \item On the dominance tree, possible to scan from top and assign colors to 
    variables as they come.
  \item Biased coloring is used to coalesce variables linked by \phifuns.
  \item see next section for more involved coalescing
  \item Fab: I think that you already talked about scan coloring. Ok to talk about biased.
  \item Fab: You can talk about biased coloring that uses the result of an aggressive coalescing (see with Quentin). It is not more complicated and it improves results.
\end{itemize}



\section{Practical and advanced discussions}

\subsection{Handling registers constraints}
\begin{itemize}
  \item ABI contraints
  \item split beforehand solution: many parallel copies, need good biased 
    coloring
  \item repair afterwards solution: biased try to give right color, else, 
    actual copies are added
  \item Fab: For the repair afterward at the time we will publish the book you will be able to cite the current paper we write on tree-scan coalescing. We plan to elaborate on the repairing mechanism and illustrate it in the context of tree-scan.
  \item Fab: For the repair afterward you will build an interference graph with negative 
affinity weights. Current coalescers do not handle it. A workaround (but 
costly) for affinity adge (a,b) with weight W<0 is replace it by an 
interference edge (a,ab) and an affinity edge (ab,b) of weight -W with ab a 
dummy node. For iterated reg-alloc (Briggs \& George's test) you can rewrite the different rules by doing as if you had such a dummy node (you virtualize it). You can discuss this with Quentin. Of course the idea is not to describe it here but it can be interesting to discuss a little bit the implications.
\end{itemize}


\subsection{Out-of-SSA and critical edge splitting}
\begin{itemize}
  \item \phifuns are not machine instructions, they are replaced by actual 
    copies in out-of-SSA phase
  \item in our case, colored SSA: Sreedhar not possible
  \item SSA implicitly 
    actual ``parallel copies'' are placed on edges
  \item problem with some critical edges: abnormal edges, back-edge of loop
  \item Fab: Sreedhar IS possible. It generates local variables not colored.
The point is that its coloring might be stucked (Chaitin reduction). So the possible need to split edges...
\end{itemize}


\subsection{More repairing on \phifuns}
\begin{itemize}
  \item Biased coloring is fast but not very good at coalescing
  \item Basic parallel copy motion: move to next edge.
  \item More involved problem: spill variables
  \item Better solution: look at biblio (parallel copy motion)
  \item Fab: Yes make it as simple as possible. Local pcopy motion works in practice. It is useless to go further. The ultimate solution (Sreedhar based) might have been discussed in the previous section
\end{itemize}


}
