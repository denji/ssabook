I like the layout that talk about phase problems between scheduling/reg-alloc/instr-selection.
Why don't you put at the same level if-conversion?

You can also say that for embedded systems, due to their specificities, it might be useful to perform transformations (usually done in the middle-end) in the back-end (eg loop unrolling, value numbering). SSA form can be useful for the same reasons it was useful at higher level (eg data dependencies, interferences provided "for free"), but some difficulties can be encountered (eg SSA destruction) mostly due to the intrinsically non SSA property of the ISA. As SSA have eventually to be destructed (but for hardware compilation) leading to some shuffle code, the machine model under SSA might lack accuracy (Conventional SSA is interesting for this purpose but maintaining conventionality is constraining and potentially difficult -- not handled in this book).

I would like you to talk about the chapter on hardware compilation. It can come after what you already wrote. The big advantage of hardware compilation is that phi functions are implementable (and apparently not much expensive). This is how you can link the paragraph on hardware compilation to classical code generation that you talked before. Actually, similar to the fact that data-flow languages are suited for hardware synthesis, SSA is a good representation also.

For the php chapter, I admit that this is a more difficult exercise. Maybe you can talk about other forms of compilation. eg dynamic compilation, JIT compilation that are not covered here but for which SSA is also suited (eg used in hotspot, lao, mono). Compilation of scripting languages adds itself to the zoo of compiler techniques. The last chapter provides a case study on compilation of php as an example of how SSA can sometimes poorly adapt to weired environments.
