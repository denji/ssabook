\chapter{Building SSA form in a compiler for PHP\\ \Author{Paul Biggar and David Gregg, Lero@TCD, Trinity College Dublin}}
\inputprogress

\providecommand{\phc}{PHC}
\providecommand{\php}[1]{\textsf{#1}}
\providecommand{\pbterm}[1]{\textsf{#1}}
\providecommand{\chref}[1]{Chapter~#1}
\providecommand{\secref}[1]{Chapter~#1}
\providecommand{\figref}[1]{Figure~#1}
\providecommand{\var}[1]{$\$#1$}
\providecommand{\comnt}[1]

\section{Introduction}

Dynamic scripting languages such as PHP, Python and Javascript are
among the most widely-used and fastest growing programming languages.

Scripting languages provide flexible high-level features, a fast
modify-compile-test environment for rapid prototyping, strong
integration with traditional programming languages, and an extensive
standard library.  Scripting languages are widely used in the
implementation of many of the best known web applications of the last
decade such as Facebook, Wikipedia, Gmail and Twitter.  Many prominent
web sites make use significant of scripting, not least because of
strong support from browsers and simple integration with back-end
databases.

One of the most widely used scripting languages is PHP, a
general-purpose language that was originally designed for creating
dynamic web pages.  PHP has many of the features that are typical of
dynamic scripting languages.  These include simple syntax, dynamic
typing, interpreted execution and run-time code generation.  These
simple, flexible features facilitate rapid prototyping, exploratory
programming, and in the case of many non-professional websites, a
copy-paste-and-modify approach to scripting by non-expert programmers.

Constructing SSA form for languages such as C/C++ and Java is a
well-studied problem. Techniques exist to handle the most common
features of static languages, and these solutions have been tried and
tested in production level compilers over many years.  In these
traditional languages it is not difficult to identify a set of scalar
variables that can be safely renamed.  Better analysis may lead to
more such variables being identified, but significant numbers of such
variables can be found with very simple analysis.

In our study of optimizing dynamic scripting languages, specifically
PHP, we find this is not the case.  The information required to build
SSA form --- that is, some conservatively complete set of unaliased
scalars, and the locations of their uses and definitions---is not
available directly from the program source, and can not be derived
from a simple analysis.  Instead, we find a litany of features whose
presence must be ruled out, or heavily analysed, in order to obtain a
non-pessimistic estimate.

Scripting languages commonly feature run-time code generation,
built-in functions, and variable-variables, all of which may alter
arbitrary unnamed variables.  Less common --- but still
possible --- features include the existence of object handlers which
have the ability to alter any part of the program state, most
dangerously a function's local symbol-table.

Ruling out the presence of these features requires precise,
inter-procedural, whole-program analysis.  We discuss the futility of
the pessimistic solution, the analyses required to provide a precise
SSA form, and how the presence of variables of unknown types affect
the precision of SSA.

% In PHP, however, simply finding the variables that which may be
% renamed into SSA is difficult, and in fact, requires the kind of
% analysis that we would like to do in SSA form. 

The rest of this chapter describes our experiences with building SSA
in \phc, our open source compiler for PHP.  We identify the features
of PHP that make building SSA difficult, outline the solutions we
found to these some of these challenges, and draw some lessons about
the use of SSA in analysis frameworks for PHP.



\section{SSA form in ``traditional'' languages}

In traditional, non-scripting languages, such as C, C++ and Java, it
is straightforward to identify which variables may be converted into
SSA form.  In Java, all scalars may be renamed.  In C and C++, any
scalar variables which do not have their address taken may be renamed.
Figure \ref{c-easy-example} shows a simple C function, whose local
variables may all be converted into SSA form.  In Figure
\ref{c-easy-example}, it is trivial to convert each variable into SSA form.
For each statement, the list of variables which are used and defined
are immediately obvious from a simple syntactic check.

\begin{figure}[thp]
\begin{verbatim}
 1: int factorial(int num) {
 2:   int result = 1, i;
 3: 
 4:   while ( num > 1 ) {
 5:     result = result * num;
 6:     num --;
 7:   }
 8:   return result;
 9: }
\end{verbatim}
\caption{Simple C code}
\label{c-easy-example}
\end{figure}


\begin{figure}[thp]
\begin{verbatim}
 1:  void func() {
 2:    int x=5, *y;
 3:    y = &x;
 4:    *y = 7;
 5:    return x;
 6:  }
\end{verbatim}
\caption{C code with pointers}
\label{c-hard-example}
\end{figure}




By contrast, Figure \ref{c-hard-example} contains variables which
cannot be trivially converted into SSA form.  On line 3, the variable
$x$ has its address taken.  As a result, to convert $x$ into SSA form,
we must know that line 4 modifies $x$, and introduce a new version of
$x$ accordingly.  \chref{hssa} describes HSSA form, a powerful way to
represent \textit{indirect} modifications to scalars in SSA form.

To discover the modification of $x$ on line 4 requires an
\textit{alias analysis}.  Alias analyses detect when multiple program
names (\textit{aliases}) represent the same memory location.  In
Figure 2, $x$ and $*y$ alias each other.

There are many variants of alias analysis, of varying complexity.  The
most complex analyse the entire program text, taking into account
control-flow, function calls, and multiple levels of pointers.
However, it is not difficult to perform a very simple alias analysis.
\textit{Address-taken alias analysis} identifies all variables whose
addresses are taken by a referencing assignment.  All variables whose
address has been taken anywhere in the program are considered to alias
each other (that is, all address-taken variables are in the same
\textit{alias set}).

When building SSA form with address-taken alias analysis, variables in
the alias set are not renamed into SSA form.  All other variables are
converted.  Variables not in SSA form do not possess any SSA
properties, and pessimistic assumptions must be made.  As a result of
address-taken alias analysis, it is straight-forward to convert any C
program into SSA form, without sophisticated analysis.  In fact, this
allows more complex alias analyses to be performed on the SSA form.

\section{PHP and aliasing}

%\subsection{Aliases}

In PHP, it is not possible to perform an address-taken alias analysis.
The syntactic clues that C provides --- notably as a result of static
typing --- are not available in PHP.  Indeed, statements which may
appear innocuous may perform complex operations behind the scenes,
affecting any variable in the function. Figure \ref{php-reference}
shows a small piece of PHP code. Note that in PHP variable names
start with the \$ sign.

\begin{figure}[thp]
\begin{verbatim}
 1:  $x = 5;
 2:  $y =& $x;
 3:  $y = 7;
\end{verbatim}
\caption{Creating and using a reference in PHP}
\label{php-reference}
\end{figure}

The most common appearance of aliasing in PHP is due to variables that
store references. Creating references in PHP does not look so very
different from C. In Figure \ref{php-reference}, the variable \var{y}
becomes a reference to the variable \var{x}. Once \var{y} has become an alias
for \var{x}, the assignment to \var{y} (in line 3) also changes the value of
\var{x}.

On first glance the PHP code in Figure \ref{php-reference} is not very
different from similar C code in Figure \ref{c-hard-example}. From the
syntax it is easy to see that a reference to the variable $x$ is
taken.  Thus, it is clear that \var{x} cannot be easily renamed. However,
the problem is actually with the variable \var{y} which contains the
reference to the variable \var{x}.

There is no type declaration to say that \var{y} in Figure
\ref{php-reference} is a reference. In fact, due to dynamic typing,
PHP variables may be references at one point in the program, and stop
being references a moment later. Or at a given point in a program a
given variable may be a reference variable or a non-reference variable
depending upon the control flow that preceeded that point.  PHP's
dynamic typing makes it difficult to simply identify when this occurs,
and a sophisticated analysis over a larger region of code is essential
to building a more precise conservative SSA form.

\begin{figure}[thp]
\begin{verbatim}
 1:  function snd($x, $y) {          1:  int snd(int x, int y) {
 2:    $x = $x + $y;                 2:    x = x + y;
 3:    return $y;                    3:    return y;
 4:  }                               4:  }
             (a)                            (b)
\end{verbatim}
\caption{Similar (a) PHP and (b) C functions with parameters}
\label{parameters}
\end{figure}

The size of this larger region of code is heavily influenced by the
semantics of function paramaters in PHP. Consider the PHP function in
Figure \ref{parameters}(a).
% function snd ($x, $y) { $x += 5; return $y; }
Superficially, it resembles the C function in Figure \ref{parameters}(b).
% int snd (int x, int y) { x += 5; return y; }
In the C version, we know that \var{x} and \var{y} are simple integer
variables and that no pointer aliasing relationship between them is
possible.  They are separate variables that can be safely renamed. In
fact a relatively simple analysis can show that the the assignment to
$x$ in line 2 of the C code can be optimized away because it is an
assignment to a dead variable.

In the PHP version in Figure \ref{parameters}(a), \var{x} may alias
\var{y} upon function entry. This can happen if \var{x} is a reference
to \var{y}, or vice versa, or if both \var{x} and \var{y} are
references to a third variable. It is important to note, however, that
the possibility of such aliasing is not apparent from the function
prototype or any type declarations. Instead, whether the formal
parametere \var{x} and/or \var{y} are references depends on the types
of actual parameters that are passed when the function is invoked. If
a reference is passed as a parameter to a function in PHP, the
corresponding formal parameter in the function also becomes a
reference.

The addition operation in line 2 of Figure \ref{parameters}(a) may
therefore change the value of \var{y}, if \var{x} is a reference to
\var{y} or vice versa. In addition, recall that dynamic typing in PHP
means that whether or not a variable contains a reference can depend
on control flow leading to different assignments. Therefore, on some
executions of a function the passed parameters may be references,
whereas on other executions they may not.

% drop this next bit
%It therefore more closely resembles the C function in \figref{5}.
% int* snd (int* x, int* y) { *x += 5; return y; }

In the PHP version, there are no syntactic clues that the variables
may alias.  As a result, a simple conservative aliasing estimate ---
similar to C's address-taken alias analysis --- would need to place
all variables in the alias set.  This would leave no variables
available for conversion to SSA form. Instead an interprocedural
analysis is needed to track references between functions.


\section{Our whole-program analysis}

PHP's dynamic typing means that program analysis cannot be performed a
function at a time.  As function signatures do not indicate whether
parameters are references, this information must be determined by
inter-procedural analysis.  Furthermore, each function must be
analysed with full knowledge of its calling context.  This requires a
whole-program analysis. We present an overview of the analysis below.
A full description is beyond the scope of this chapter, and can be
found elsewhere \cite{Biggar2010}.

\subsection{The analysis algorithm}
The analysis is structured as a symbolic execution.  This means the
program is analysed by processing each statement in turn, and
modelling the affect of the statement on the program state.  This is
similar in principle to the sparse conditional constant propagation
(SCCP) algorithm \secref{sccp}.\footnote{The analysis is actually
  based on a variation, conditional constant propagation
  \cite{Pioli99}.}


The SCCP algorithm models a function at a time.  Instead, our
algorithm models the entire program.  The execution state of the
program begins empty, and the analysis begins at the first statement
in the program, which is placed in a worklist.  The worklist is then
processed a statement at a time.

For each analysed statement, the results of the analysis are stored.
If the analysis results change, the statement's successors (in the
control-flow graph) are added to the worklist. This is similar to
CFG-edges in the SCCP algorithm.  There is no parallel to the SSA
edges, since the analysis is not performed on the SSA form.  Instead,
loops must be fully analysed if their headers change.

This analysis is therefore less efficient than the SCCP algorithm, in
terms of time.  It is also less efficient in terms of space.  
%As described in \figref{gcc}, 
SSA form allows results for to be compactly stored in a single array,
using the SSA index as an array index.  This is very space efficient.
In our analysis, we must instead store a table of variable results at
all points in the program.

Upon reaching a function or method call, the analysis begins analysing
the callee function, pausing the caller's analysis.  A new worklist is
created, and initialized with the first statement in the callee
function.  The worklist is then run until it is exhausted.  If another
function call is analysed, the process recurses.

Upon reaching a callee function, the analysis results are copied into
the scope of the callee.  Once a worklist has ended, the analysis
results for the exit node of the function are copied back to the
calling statement's results.

\subsection{Analysis results}

Our analysis computes and stores three different of kinds of results.
Each kind of result is stored at each point in the program.

The first models the alias relationships in the program in a
\textit{points-to graph} \cite{EGH1994}.  The graph contains variable
names as nodes, and the edges between them indicate aliasing
relationships.  An aliasing relationship indicates that two variables
either \textit{must}-alias, or \textit{may}-alias.  Two unconnected
nodes cannot alias.  A points-to graph is stored for each point in the
program.  Graphs are merged at CFG join points.

Secondly, our analysis also computes a conservative estimate of the
types of variables in the program.  Since PHP is an object-oriented
language, polymorphic method calls are possible, and they must be
analysed.  As such, the set of possible types of each variable is
stored at each point in the program.  This portion of the analysis
closely resembles using SCCP for type propagation \cite{Lenart2000},
as described in \secref{sccp}.

Finally, like the SCCP algorithm, constants are identified and
propagated through the analysis of the program. Where possible, the
algorithm resolves branches statically using propagated constant
values. This is particularly valuable because our \phc ahead-of-time
compiler for PHP creates many branches in the intermediate
representation during early stages of compilation.  Resolving these
branches statically eliminates unreachable paths, leading to
significantly more precise results from the analysis algorithm.


\subsection{Building def-use sets}

To build SSA form we need to be able to identify the set of points in
a program where a given variable is defined or used. Since we cannot
easily identfiy these sets due to potential aliasing, we build them as
part of our program analysis.  Using our alias analysis, any variables
which may be written to or read from during a statement's executation,
are added to a set of defs and uses for that statement.  These are
then used during construction of the SSA form.

For an assignment by copy, \php{\$x = \$y}:

\begin{enumerate}
	\item
		\php{\$x}'s value is defined.
	\item
		\php{\$x}'s reference is used (by the assignment to \php{\$x}).
	\item
		for each alias \php{\$x'} of \php{\$x}, \php{\$x'}'s
                value is defined.  If the alias is \pbterm{possible},
                \php{\$x'}'s value is may-defined instead of defined.
                In addition, \php{\$x'}'s reference is used.
	\item
		\php{\$y}'s value is used.
	\item
		\php{\$y}'s reference is used.

\end{enumerate}

For an assignment by reference, \php{\$x =\& \$y}:

\begin{enumerate}
	\item
		\php{\$x}'s value is defined.
	\item
		\php{\$x}'s reference is defined (it is not
                used --- \php{\$x} does not maintain its previous
                reference relationships).

	\item
		\php{\$y}'s value is used.

	\item
		\php{\$y}'s reference is used.

\end{enumerate}



\subsection{HSSA}

Once the set of locations where each variable is defined or used has
been identified, we have the information needed to construct SSA.
However, it is important to note that due to potential aliasing and
potential side effects of some difficult-to-analyse PHP features (see
section \ref{other-difficult-features}) many of the definitions we
compute are may-definitions. Whereas a normal definition of a variable
means that that variable will definitely be defined, a may-definition
means that the variable may be defined at that point\footnote{Or more
  precisely, a may-definition means that a conservative analysis is
  unable to show that there does not exist some execution of the
  program where the variable is defined at that point.}. In order to
accomodate these may-definitions in our SSA form for PHP we use a
variation of hashed SSA, described in \secref{hssa}. As in HSSA, we
use $\chi$ nodes, to model may-definitions.

The final distinction from traditional SSA form is that we do not only
model scalar variables.  All names in the program, such as fields of
objects or the contents of arrays, can be represented in SSA form.


\section{Other challenging PHP features}
\label{other-difficult-features}

For simplicity, the description so far of our algorithm has only
considered the problems arising from aliasing due to PHP reference
variables. However, in the process of construction SSA in our PHP
compiler several other PHP language features that make it difficult to
identify all the points in a program where a variable may be
defined. In this section we briefly describe these language features
and how they may be dealt with in order to conservatively identify all
may-definitions of all variables in the program.

\subsection{Run-time symbol tables}
\label{run-time-tables}
\comnt{
Variable names in PHP appear to be similar to names in traditional
language such as C/C++ and Java, except that all PHP variable names
start with the \$ symbol. However, there is also an important semantic
difference related to the naming of variables.  In PHP variables are
simply a map from strings to values. Each PHP function has its own
local map, and there is also a single global map shared among all
functions. When a PHP programmer writes the assignment $\$x = 7;$ the
semantics are that the value 7 is associated with the string $x$ in
the function's local map. Most of the time we can simply ignore these
semantics and think of \var{x} as a local variable, but it is possible
for the programmer to exploit this feature using a technique known as
variable-variables \cite{Biggar2010}.
}

Figure \ref{variable-variable} shows a program which accesses a
variable indirectly.
% $x = 5; $var_name = readline(); $$var_name = 6; print $x;
On line 2, a string value is read from the user, and stored in the
variable \var{var\_name}.  On line 3, some variable---whose name is the
value in \var{var\_name} --- is set to 5.  That is, any variable can be
updated, and the updated variable is chosen by the user at run-time.
It is not possible to know whether the user has provided the value
$"x"$, and so know whether \var{x} has the value $5$ or $6$.

\begin{figure}[thp]
\begin{verbatim}
 1:  $x = 5;
 2:  $var_name = readline( );
 3:  $$var_name = 6;
 4:  print $x;
\end{verbatim}
\caption{PHP code using a variable-variable}
\label{variable-variable}
\end{figure}

This feature is known as \textit{variable-variables}.  They are
possible because a function's symbol-table in PHP is available at
run-time.  Variables in PHP are not the same as variables in C.  A C
local variable is a name which represents a memory location on the
stack.  A PHP local variable is the domain of a map from strings to
values.  The same run-time value may be the domain of multiple string
keys (references, discussed above).  Similarly, variable-variables
allow the symbol-table to be accessed dynamically at run-time,
allowing arbitrary values to be read and written.

Upon seeing a variable-variable, all variables may be written to.  In
HSSA form, this creates a $\chi$ node for every variable in the
program.  In order to reduce the set of variables that might be
updated by assigning to a variable-variable, the contents of the
string stored in \var{var\_name} may be modelled using string analysis
\cite{Wassermann2007}.  String analysis is a static program analysis
that models the structure of strings.  For example, string analysis
may be able to tell us that the name stored in the variable-variable
(that is the name of the variable that will be written to) begins with
the letter ``x''.  In this case, all variables which do not begin with
``x'' do not require a $\chi$ node, leading to a more precise SSA form.

% This next one seems like a minor and slightly obscure point:
% Variable-variables are not the only PHP feature which can affect the
% local symbol-table.  \figref{7} shows a function call which can affect
% the variables in the scope of the caller.
% $x = 5; extract (readline()); print $x;
\subsection{Execution of arbitrary code}
PHP provides a feature that allows an arbitrary string to be executed
as code. This $eval$ statement simply executes the contents of any
string as if the contents of the string appeared inline in the
location of the $eval$ statement. The resulting code can modify local
or global variables in arbitary ways. The string may be computed by
the program or read in from the user or from a web form.

The PHP language also allows the contents of a file to be imported
into the program text using the $include$ statement. The name of the
file is an arbitary string which may be computed or read in at run
time. The result is that any file can be included in the text of the
program, even one that has just been created by the program.  Thus,
the $include$ statement is potentially just as flexible as the $eval$
statement for arbitarily modifying program state.

Both of these may be modelled using the same string analysis
techniques \cite{Wassermann2007} as discussed in Section
\ref{run-time-tables}.  The $eval$ statement may also be handled using
profiling \cite{Furr2009}, which restricts the set of possible $eval$
statements to those which actually are used in practice.

\subsection{Object handlers}
PHP's reference implementation allows classes to be partially written
in C.  Objects which are instantiations of these classes can have
special behaviour in certain cases.  For example, the objects may be
dereferenced using array syntax. Or a special handler function may be
called when the variable holding the object is read or written to.

The handler functions for these special cases are generally
unrestricted, meaning that they can contain arbitrary C code that does
anythiny the programmer chooses.  Being written in C, they are given
access to the entire program state, including all local and global
variables.

There two characteristics of handlers make them very powerful, but
break any attempts at function-at-a-time analysis.  If one of these
objects is passed in to a function, and is read, it may overwrite all
variables in the local symbol table.  The overwritten variables might
then have the same handlers.  These can then be returned from the
function, or passed to any other called functions (indeed it can also
call any function).  This means that a single unconstrained variable
in a function can propagate to any other point in the program, and we
need to treat this case conservatively.


\section{Discussion, implications and conclusion}
In this chapter we have described our experience of building SSA in
\phc, an ahead-of-time compiler for PHP. PHP is quite different to
traditional static languages such as C/C++ and Java. In addition to
dynamic typing it has other dynamic features such as very flexible and
powerful reference types, variable-variables, and features that allow
almost arbitrary code to be executed. 

The main result of our experience is to show that SSA cannot be used
and an end-to-end intermediate representation (IR) for a PHP
compiler. The main reason is that in order to build SSA, significant
analysis of the PHP program is needed to deal with aliasing and to
rule out potential arbitrary updates of variables. We have found that
in real PHP programs these features are seldom used in way that make
analysis really difficult \cite{Biggar2010}. But analysis is
nonethless necessary to show the absence of the bad used of these
features.

In principle our analysis could perform only the alias analysis prior
to building SSA, and perform type analysis and constant propagation in
SSA. But our experience is that combining all three analyses greatly
improves the precision of alias analysis.  In particular, type
analysis significantly reduces the number of possible method callees
in object-oriented PHP programs.

The complexity of building SSA for PHP suggests that we are unlikely
to see SSA used in just-in-time (JIT) compilers for PHP soon. There is
a great deal of interest in building JIT compilers for scripting
languages, especially Javascript, but most of the effort is aimed at
eliminating dynamic type checks using profiling and trace methods
\cite{Gal:2009}, rather than static analysis.

Once built the SSA representation forms a platform for for further
analysis and optimization. For example, we have used it to implement
an aggressive dead-code elimination pass which can eliminate both
regular assignments and reference assignments.

In recent years there has been increasing interest in the static
analysis of scripting languages, with a particular focus on detecting
potential security weaknesses in web-based PHP programs. For example,
Jovanovic et al. \cite{Jovanovic06pixy:a} describe an analysis of PHP
to detect vulnerabilities that allow the injection of executable code
into a PHP program by a user or web form. Jensen et al.  describe an
alias analysis algorithm for Javascript which works quite differently
to ours \cite{Biggar2010}, but works well for Javascript
\cite{Jensen+2009}.

To our knowledge we are the first to investigate building SSA in a PHP
compiler. Our initial results show that building a reasonably precise
SSA for PHP requires a great deal of analysis. Nonetheless, as
languages such as PHP are used to build a growing number of web
applications, we expect that there will be an increasing interest in
tools for the static analysis of scripting languages.

\subsection*{Acknowledgements}
This work was supported in part by Science Foundation Ireland
grant 10/CE/I1855 to Lero -- the Irish Software Engineering
Research Centre (www.lero.ie).



