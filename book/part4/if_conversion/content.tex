\chapter{if conversion \Author{C. Bruel}}
\numberofpages{10}

\section{Overview/Motivations}

Explain if-conversion benefits and architectural contextes

    \begin{itemize}
    \item Definition:
    \end{itemize}
If-conversion is traditionally referred as the process into which a compiler transforms control flow dependencies into data flow dependencies. The goal of this transformation is to increase instruction level parallelism by moving different control paths into a single one while removing conditional branches, main impediment for instruction level parallelism.

This optimisation needs a very strong knowledge of the target machine to decide how (predication, speculation, conditional moves, predicate computation and merge)to decide how complex control flow region (an hyperblock) can be transformed into an equivalent set of conditionalized instruction. So it is usually limited to compiler backends and are target specifics.

    \begin{itemize}
    \item problem and alternatives
    \item Architectural supports, 
    \end{itemize}

\section{SSA transformations}

\textbf{4 pages}

Describe local SSA transformation used for if-conversion

    \begin{itemize}

    \item Scope

    \item SSA reductions and phi augmentation

    \item SSA to SSA if-conversion

    \item SSA to PSI SSA if-conversion

    \item Examples

    \end{itemize}

\section{Hyperblock Region contruction}

\textbf{4 pages}

Describe global region construction and heuristics

    \begin{itemize}

    \item Objective functions, resources costs

    \item Iterative postorder construction

    \item SSA maintenance

    \item Speculation versus predication

    \item Examples

    \end{itemize}




