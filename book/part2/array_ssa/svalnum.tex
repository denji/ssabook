In this section, we show how global value numbering and allocation
site information can be used to efficiently 
compute
{\it definitely-same} ($\DS$) and {\it definitely-different}
($\DD$) information for 
heap array indices, thereby 
reducing pointer analysis queries to array index queries.
If more sophisticated pointer analyses are available in a compiler,
they can be used to further refine the $\DS$ and $\DD$ information.

As an example, 
Figure~\ref{fig:ex2} illustrates two different cases of scalar
replacement (load elimination) for object fields. 
The notation {\tt Hx[p]} refers to a read/write access of heap array
element, 
$\HA^x[p]$.
For the original program in figure~\ref{fig:ex2}(a),
introducing a scalar temporary {\tt T1} for the store (def) of {\tt
p.x} can enable the load (use) of {\tt r.x} to be eliminated \ie\ to
be replaced by a use of {\tt T1}.  Figure~\ref{fig:ex2}(b)
contains an example in which a scalar temporary ({\tt T2}) is
introduced for the first load of {\tt p.x}, thus enabling the second
load of {\tt r.x} to be eliminated \ie\ replaced by {\tt T2}. 
In both cases, the goal of our analysis is to determine that the load
of {\tt r.x} is redundant, thereby enabling
the compiler to replace it by 
a use of scalar temporary that captures the value in {\tt p.x}.
We need to establish two facts to perform this transformation:
1) object references $p$ and $r$ are identical (definitely same) in 
all program executions, and 2)
object references $q$ and $r$ are distinct (definitely different) in
all program executions. 

As before, we use the notation $\V(i)$ to denote the value number of SSA 
variable $i$.  Therefore, if $\V(i) = \V(j)$, then 
$\DS(i,j)$ = {\it true}.  
For the code fragment above, the  statement, {\tt p~:=~r},
ensures that $p$ and $r$ are given the same value number,
$\V(p) = \V(r)$, so that $\DS(p,r)$ = {\it true}.
The problem of
computing $\DD$ for object references is more complex than value numbering, and relates
to pointer alias analysis.  We outline a simple  and sound approach
below, which can be replaced by more sophisticated techniques as needed.
It relies on two observations related to allocation-sites:
\begin{enumerate}
\item Object references that contain the results of distinct allocation-sites
must be different.
\item An object reference containing the result of an allocation-site
must be different from any object reference 
that occurs at a program point that dominates the allocation site in the control flow graph.
For example, in Figure~\ref{fig:ex2},
the presence of the allocation site in {\tt q~:=~new~Type1}
ensures that $\DD(p,q) = \mbox{\it true}$.
\end{enumerate}


\REM{
As an example, consider the heap array representation
for the three-address code for the Java method
{\tt foo()} introduced in figure~\ref{fig:java}.
After carefully examining the control and data flow in
method {\tt foo()}, we can conclude that
the read access of heap array element 
$\HA^x[r]$ (\ie\ field {\tt p.r})
will have a constant value (=~1).

{\it Vivek: problem above. $\HA^x[r]$ (\ie\ field {\tt p.r}) should
that be r.x???}

{\it Vivek: problem below (and also above). there is no r in the example.}


Consider the three statements in figure~\ref{fig:DD-ex-source}

\begin{figure}%[htbp]

\begin{center}
\parbox{2.5in}{
\begin{programa}
\Ta $p.y := 1$ \\
\Ta $q.y := \ldots$ \\
\Ta $\ldots := r.y * 2$ \\
\end{programa}
}
\end{center}
\caption{Java Source Code Motivating \DD and \DS Analysis}
\label{fig:DD-ex-source}
\end{figure}


We may be able to propagate the value 1 from the assignment in the
first statement to the use in the third.  But to be able to justify
this conclusion, we need to establish two facts:

\begin{enumerate}
\item Object references $p$ and $r$ are identical (definitely same) in 
all program executions.
\item Object references $q$ and $r$ are distinct (definitely different) in
all program executions. 
\end{enumerate}


For a program in SSA form, we 
say that $\DS(a,b) =
\mbox{\it true}$ if and only if variables
$a$ and $b$ are known to have exactly
the same value
at all points that are
dominated by the definition of $a$ and dominated by the definition of $b$.
If, $a$ and $b$ are
constants (or discovered to be constants)
then $\DS(a,b) = \mbox{\it true}$ if and only if $a=b$.
Analogous to $\DS$, $\DD$ denotes a ``definitely-different'' binary
relation \ie $\DD(a,b) = \mbox{\it true}$ if and only if $a$ and
$b$ are known to have distinct (non-equal) values
at all points that are
dominated by the definition of $a$ and dominated by the definition of $b$.
If, $a$ and $b$ are constants then $\DD(a,b) = \mbox{\it
true}$ if and only if $a\not=b$.

We now discuss the compile-time
computation of the $\DS$ and $\DD$ relations for symbolic
indices. 
Given scalar variables $I_1$ and $I_2$
in SSA form, only one of the following three cases
is possible:
\begin{center}
\parbox{2.5in}{
\begin{programa}
$\DS$($I_1$, $I_2$) = FALSE; $\DD$($I_1$, $I_2$) = FALSE \\
$\DS$($I_1$, $I_2$) = TRUE; $\DD$($I_1$, $I_2$) = FALSE \\
$\DS$($I_1$, $I_2$) = FALSE; $\DD$($I_1$, $I_2$) = TRUE \\
\end{programa}
}
\end{center}
The first case is the most conservative solution.  In the absence of
any other knowledge, it is always correct to state that
$\DS(I_1,I_2) = \mbox{\it false}$ and $\DD(I_1,I_2) = \mbox{\it
false}$.

The problem of determining if two symbolic index values are the same
is equivalent to the classical problem of {\it global value
numbering}~\cite{AlWZ88,Much97}. If two indices $i$ and $j$ have the
same value number, then $\DS(i,j)$ must = {\it true}.  As mentioned
earlier, our approach is to compute the $\DS$ relation only for scalar
variables as a pre-pass to the constant propagation and scalar
replacement analyses.  Since our framework use Array SSA form, it is
most convenient to use an efficient scalar global value numbering
algorithm based on SSA form (such as the algorithm in
\cite{AlWZ88}) for this purpose. $p$ and $r$ are found to be in the
same partition as a result of the global value number of scalars on
the three-address code in figure~\ref{fig:java}.


\REM{ 
For the three-address code in figure~\ref{fig:java}, we would obtain the
following partitioning after global value numbering of scalars:
$$
\{ p, r \},
\{ a \},
\{ i \},
\{ j \},
\{ q \},
\{ t1 \}, \{ t2 \}, \{ t3 \}, \{ t4 \}, \{ t5 \},
\{ t1 \}, \{ t2 \}, \{ t3 \}, \{ t4 \}, \{ t5 \},
\{ t6 \}, \{ t7 \}, \{ t8 \}, \{ t9 \}, \{ t10 \}
$$
}
The problem of
computing $\DD$ is more complex.  Note that $\DD$, unlike $\DS$, is not
an equivalence relation because $\DD$ is not transitive.  If $\DD(A,
B)=\mbox{\it true}$ and $\DD(B, C)=\mbox{\it true}$, it does not imply
that $\DD(A, C)=\mbox{\it true}$.  For computing $\DD$ for array
subscripts, we can leverage past work on data dependence
analysis~\cite{Wolf89} to identify many simple but common cases for
which $\DD$ can be evaluated to {\it true}.  For example, it is clear
that $\DD(i, i+1) = \mbox{\it true}$, and that $\DD(i, 0) = \mbox{\it
true}$ if $i$ is a loop index variable that is known to be $\geq 1$.

For Java object references, we use allocation-site information to compute
the $\DD$ relation.  In particular, we rely on two observations:
\begin{enumerate}
\item Object references that contain the results of distinct allocation-sites
must be different.
\item An object reference containing the result of an allocation-site
in the method must be distinct from an object reference that's a parameter.
\end{enumerate}
These observations can be illustrated in the three-address code in
Figure~\ref{fig:java}.  Global value numbering can be used to
determine that $\V(p) = \V(r)$ \ie\ $\DS(p,r) = \True$,
and the above allocation-site observations can be used to determine
that $\V(p) \not= \V(q)$ \ie\ $\DD(p,q) = \True$.
In general, knowing that $\V(p) \not= \V(q)$ allows
us to conclude that $\DD(a,b) = \True$ whenever 
$\V(a) = \V(p)$ and $\V(b) = \V(q)$.



{\it
TODO (VIVEK): use the idea of ``uniformly-generated'' index expressions to efficiently
represent $\DD$ information for integer-valued array indices???
}

}

% In the remainder of the chapter,
% we will use the notation $\V(\vec{k})$ to represent a vector
% of value numbers, $(\V(k_1), \ldots)$, 
% given a vector index $\vec{k} = (k_1,
% \ldots)$.
% Thus, $\DS(\vec{j}, \vec{k})$
% is {\it true} if and only if vectors $\vec{j}$ and $\vec{k}$ have the
% same size, and their corresponding elements are definitely-same \ie\
% $\DS(j_i,k_i )= \mbox{\it true}$ for all $i$.  Analogously,
% $\DD(\vec{j}, \vec{k})$ is {\it true} if and only if vectors $\vec{j}$
% and $\vec{k}$ have the same size, and at least one pair of elements is
% definitely-different \ie\ $\DD(j_i,k_i )= \mbox{\it true}$ for some~$i$.


\begin{figure}
{\small
\begin{tabular}[t]{ll}
\begin{minipage}[t]{2.5in}
\setlength{\baselineskip}{10pt}
Original program: \\
%-----------------
\begin{verbatim}
  r  := p
  q  := new Type1
  . . .
 p.x := ...  // Hx[p] := ...
 q.x := ...  // Hx[q] := ...
 ... := r.x  //   ... := Hx[r]

\end{verbatim} 
\bigskip
After redundant load elimination: \\
%---------------
\begin{verbatim}
  r  := p
  q  := new Type1
  . . .
  T1 := ...
 p.x := T1 
 q.x := ...
 ... := T1
\end{verbatim} 
\begin{center}
(a)
\end{center}
\end{minipage}
&
\begin{minipage}[t]{2.5in}
\setlength{\baselineskip}{10pt}
Original program: \\
\begin{verbatim}
  r  := p
  q  := new Type1
  . . .
 ... := p.x   //   ... := Hx[p]
 q.x := ...   // Hx[q] := ...
 ... := r.x   //   ... := Hx[r]

\end{verbatim} 
\bigskip
After redundant load elimination: \\
%---------------
\begin{verbatim}
  r  := p
  q  := new Type1
  . . .
  T2 := p.x
 ... := T2
 q.x := ...
 ... := T2
\end{verbatim} 
\begin{center}
(b)
\end{center}
\end{minipage}
% &
% \begin{minipage}[t]{2.0in}
% \setlength{\baselineskip}{10pt}
% Original program: \\
% \begin{verbatim}
%   p  := new Type1
%   q  := new Type1
%   r  := p
%   . . .
%  p.x := ...
%  q.x := ...
%  r.x := ...
% \end{verbatim} 
% \bigskip
% After dead store elimination: \\
% %---------------
% \begin{verbatim}
%   p  := new Type1
%   q  := new Type1
%   r  := p
%   . . .
%  q.x := ...
%  r.x := ...

% \end{verbatim} 
% \begin{center}
% (c)
% \end{center}
% \end{minipage}
\end{tabular}
}
\caption{Examples of scalar replacement}
\label{fig:ex2}
\end{figure}
