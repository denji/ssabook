% TODO:
% 1) Replace earlier Array SSA example by the same one used for
% constant propagation

% The goal of Array SSA form is to provide the same benefits for arrays
% and related data structures
% that traditional SSA form provides for scalars.
% Section~\ref{sec:full} summarizes  {\it full Array SSA form}, which provides exact use-def information 
% at run-time for each dynamic access of an array element.
% Section~\ref{sec:partial} introduces {\it partial Array SSA form} as a
% static approximation of full Array SSA form.
% Throughout this chapter,
% we assume that all array operations in the input program are
% expressed as reads and writes of individual array elements.  The
% extension to more complex data structures such as arrays of
% structures and nested arrays 
% has been
% omitted to simplify the presentation of this chapter.

%\subsection{Full Array SSA Form}\label{sec:full}

% The full Array SSA form uses $\Phi$ operators instead of $\phi$
% functions used by traditional SSA form. The semantics of the $\Phi$
% operator can be defined as a pure function.  
% This is one respect in which Array SSA form
% has
% advantages over traditional SSA form even for scalar variables.
% {\it @ variables} (pronounced ``at variables'')
% are used to obtain a pure function semantics for the
% $\Phi$
% operator. Each
% $\phi$ function in traditional SSA form such as $\phi(S_1,S_2)$ is
% rewritten as $\Phi(S_1,@S_1,S_2,@S_2)$.  

To introduce full Array SSA form with runtime evaluation of $\Phi$
functions,
we use the concept of an  {\it iteration vector} to differentiate among multiple dynamic
instances of a static definition, $S_k$, that occur in the same
dynamic instance of $S_k$'s enclosing procedure, $f()$.
% The {\it iteration vector} of a 
% static 
% definition $S_k$ identifies a single iteration in the iteration space of the
% set of loops
% that enclose the definition. 
Let $n$ be the number of loops that enclose $S_k$ in procedure $f()$.
These loops could be for-loops, while-loops, or even loops constructed
out of goto statements.
For convenience, we treat the outermost
region of acyclic control flow in a procedure as a dummy outermost loop
with a single iteration, thereby ensuring that $n \geq 1$.

A single point in the
iteration space is specified by the iteration vector
$\vec{i} = (i_1, \ldots, i_n)$, which is
an 
$n$-tuple of iteration numbers,
<one for each enclosing loop. 
For convenience, this definition of iteration vectors assumes that  
all loops are single-entry, or equivalently, that the control-flow graph is {\it reducible}.
(This assumption is not necessary
for partial Array SSA form.)
For single-entry loops, we know that each def executes at most
once in a given iteration of its surrounding loops, hence the iteration vector
serves the purpose of a ``timestamp''.
The key extensions in Array SSA form relative to standard SSA form are as
follows.



\begin{enumerate}
\item {\bf Renamed array variables:}
All array variables are renamed so as to 
satisfy the static single assignment property.  Analogous to standard SSA
form, control $\Phi$ operators are introduced to generate new names
for merging two or more prior definitions at control flow join points, and to ensure that each use
refers to precisely one definition.

\item {\bf Array-valued @ variables:}
For each static definition
$A_j$, we introduce an {\em @ variable} (pronounced ``at variable'')
$@A_j$ that identifies
the most recent {\em iteration vector} {\it
at} which definition $A_j$ was executed.
We assume that all @ variables are initialized to the empty
vector, $ (\;)$, at the start of program execution.  
% For each
% real (non-$\Phi$) definition of a renamed scalar, $S_k$, we assume that a statement of the
% form $@S_k := \vec{i}$ is inserted immediately after definition
% $S_k$, where $\vec{i}$
% is the current iteration vector for all loops that surround
% $S_k$. 
% All @ variables are initialized
% to the empty vector because the empty vector is the identity element
% for a lexicographic $\max$ operation \ie\ $\max((\;),\vec{i}) =
% \vec{i}$, for any @ variable value $\vec{i}$.
% Each  array variable, $A_j$, in Array SSA form has an associated 
% @ variable, $@A_j$, such that $@A_j$ has
% the same shape (rank and dimension sizes) as array variable $A_j$.
Each update of a single array element, $A_j[k] := \ldots$, 
is followed by the statement, $@A_j[k] := \vec{i}$
where $\vec{i}$ is the iteration vector for the loops surrounding
the definition of $A_j$.
% Thus, an array-valued @ variable, $@A_j$,  
% can record a separate iteration vector for
% each element that is assigned by definition $A_j$.


\item {\bf Definition $\Phi$'s:}
\label{def:phi}
A  {\it definition}-$\Phi$ operator is 
introduced in Array SSA form to deal with preserving (``non-killing'') definitions
of arrays.  Consider $A_0$ and $A_1$, two renamed 
arrays that originated from the same array variable in the source program
such that $A_1[k] := \ldots$
is an update of a single array element
and $A_0$ is the prevailing definition at the program point just
prior to the definition of $A_1$.
A definition $\Phi$, $A_2 := d\Phi(A_1, @A_1, A_0, @A_0)$,
is inserted immediately after the definitions for $A_1$ and $@A_1$.
% (We use the notation $d\Phi$ when we want to 
% distinguish a definition $\Phi$ operator from a control $\Phi$ operator.)
Since definition $A_1$ only updates one element of $A_0$, $A_2$ represents
an element-level merge of arrays $A_1$ and $A_0$.
Definition $\Phi$'s did not need to be
inserted in standard SSA form because a scalar definition completely kills the old value of
the variable.  


\item {\bf Array-valued  $\Phi$ operators:}
\label{array:phi}
Another consequence of renaming arrays is that
a $\Phi$ operator
for array variables must also return an
array value.  Consider a (control or definition) $\Phi$ operator of
the form, $A_2 := \Phi(A_1, @A_1, A_0, @A_0)$. Its semantics can be specified precisely
by the following conditional expression
for each element, $A_2[j]$, in the result array $A_2$:
\begin{eqnarray}
A_2[j] & = &
  \begin{array}{llll}
\mbox{\bf if} & @A_1[j] \succeq @A_0[j] & \textbf{then} & A_1[j] \\
\mbox{\bf else} & A_0[j] \\
\mbox{\bf end if} \label{eqn:cond-expr}
  \end{array}
\end{eqnarray}
The key extension over the scalar case is that the conditional expression
specifies an element-level merge of arrays $A_1$ and $A_0$.
\end{enumerate}





Figures~\ref{fig:ssa-acyclic-array} and \ref{fig:full-form}
show an example program with an
array variable, and the conversion of the program to full Array SSA form as
defined above.

\begin{figure}%[p]
\begin{center}
\parbox{3.0in}{
\begin{programa}
%\mbox{n1:}
\Tb $A[*] := \mbox{\rm initial value of $A$}$\\
\Tb$i := 1$ \\
\Tb $C := i\ <\ 2 $\\
\Tb if $C$ then \\
%\mbox{n2:}
\Tc $k := 2\ *\ i$ \\
\Tc $A[k] := i$\\
\Tc print $A[k]$\\
\Tb endif \\
%\mbox{n3:}
\Tb print $A[2]$
\end{programa}
}\\
\end{center}
\caption{Example program with array variables}
\label{fig:ssa-acyclic-array}
\end{figure}


\begin{figure}%[p]
\begin{center}
\parbox{3.0in}{
\begin{programa}
%\mbox{n1:}
%\Tb $@i := (\;)$ ; $@C := (\;)$ ; $@k := (\;)$ ; \\
\Tb $@A_0[*] := (\;)$ ; $@A_1[*] := (\;)$\\
\\
\Tb $A_0[*] := \mbox{\rm initial value of $A$}$\\
\Tb $@A_0[*] := (1)$\\
\Tb $i := 1$ \\
%\Tb $@i := (1)$ \\
\Tb $C := i\ <\ n $ \\
%\Tb $@C := (1)$ \\
\Tb if $C$ then \\
%\mbox{n2:}
\Tc $k :=  2\ *\ i$ \\
%\Tc $@k := (1)$ \\
\Tc $A_1[k] := i$\\
\Tc $@A_1[k] := (1)$\\
\Tc $A_2 := d\Phi(A_1, @A_1, A_0, @A_0)$\\
\Tc $@A_2 := \max(@A_1, @A_0)$\\
\Tc print $A_2[k]$\\
\Tb endif \\
%\mbox{n4:} 
\Tb $A_3 := \Phi(A_2, @A_2, A_0, @A_0)$\\
\Tb $@A_3 := \max(@A_2, @A_0)$\\fig:
\Tb print $A_3[2]$ 
\end{programa}
}
\end{center}
\caption{Conversion of program in figure \protect{\ref{fig:ssa-acyclic-array}} to Full Array SSA Form}
\label{fig:full-form}
\end{figure}

We now introduce a {\it partial Array SSA form} for static analysis,
that serves as an approximation of full Array SSA form.
Consider a (control or definition) $\Phi$ statement, $A_2 := \Phi(A_1, @A_1, A_0, @A_0)$.
A static analysis will need to 
approximate
the computation of this $\Phi$ operator by 
some data flow transfer function, $\L_{\Phi}$.
The inputs and output of $\L_{\Phi}$ will be
{\it lattice elements} for scalar/array variables that
are compile-time approximations of their run-time values.
We use the notation $\L(V)$ to denote the lattice element for 
a scalar or array
variable $V$.
Therefore, the 
statement, $A_2 := \Phi(A_1, @A_1, A_0, @A_0)$, will in general
be modeled by the data flow equation,
$\L(A_2) = \L_{\Phi}(\L(A_1), \L(@A_1), \L(A_0), \L(@A_0))$.

While the  {\em runtime} semantics of 
$\Phi$ functions for array variables critically depends on @ variables (Equation~\ref{eqn:cond-expr}),
many {\em compile-time analyses} do not need the full generality of @ variables.  
For analyses that do not distinguish among iteration instances,
it is sufficient to model
$A_2 := \Phi(A_1, @A_1, A_0, @A_0)$ by
a data flow equation, $\L(A_2) = \L_{\phi}(\L(A_1), \L(A_0))$,
that does not use lattice variables $\L(@A_1)$ and $\L(@A_0)$.
For such cases, a {\it partial}
Array SSA form can be obtained by dropping 
dropping @ variables, and using the
$\phi$ operator, $A_2 := \phi(A_1, A_0)$ instead of
$A_2 := \Phi(A_1, @A_1, A_0, @A_0)$.  
A consequence of dropping @ variables is that partial Array
SSA form does not need to deal with iteration
vectors, and therefore does not require the control-flow graph to be {\it reducible} as in full Array SSA form.
For scalar variables, the resulting $\phi$ operator obtained by
dropping @ variables exactly coincides with standard SSA form.
% The use of $\phi$ operators without @ variables brings
% partial Array SSA form closer to traditional SSA form.
% The key difference is that partial Array SSA form still contains 
% renamed arrays and definition $\phi$ operators for updates to array elements.



% Our first observation is that there is no extra information
% provided at compile-time by the @ variables
% for any static analysis that does not distinguish between reachable code
% and unreachable code.  In such cases,
% it is sufficient to model
% $A_2 := \Phi(A_1, @A_1, A_0, @A_0)$ by
% a data flow equation of the form $\L(A_2) = \L_{\phi}(\L(A_1), \L(A_0))$
% that does not use lattice variables $\L(@A_1)$ and $\L(@A_0)$.
% For array variables, the only useful information
% provided by an @ variable, $@A_1$ (say), at compile-time is an indication
% of which elements were updated by the assignment to array $A_1$.  
% %The actual ``timestamp'' (iteration vector) for the assignment is not
% %relevant if all paths are considered to be reachable.
% However, as we will see in section~\ref{sec:arraylattice}, this information
% is also included in the lattice value $\L(A_1)$ for array $A_1$. 

% Our second observation is that
% a static analysis that needs to distinguish between unreachable
% code and reachable code can do so efficiently
% by introducing {\it executable flags} for nodes and edges in the
% CFG (Control Flow Graph) as i.
% If executable flags are computed in the data flow analysis, then
% the @ variables again do not provide any useful extra information.
% In fact, if we consider a control $\Phi$ statement
% $A_2 := \Phi(A_1, @A_1, A_0, @A_0)$, with array values $A_1$ and $A_0$
% carried by incoming CFG edges $e1$ and $e0$ respectively, then
% the corresponding data flow equation (in the presence of unreachable code
% elimination) will be 
% $\L(A_2) = \L_{\Phi}(\L(A_1), X_{e1}, \L(A_0), X_{e0})$ where 
% $X_{e1}$ and $X_{e0}$ are the executable flags for edges $e1$ and $e0$.
% (Full details can be found i.)

% Since @ variables need not be modeled for the
% compile-time analyses discussed in this chapter,
% we drop them and use the
% $\phi$ operator, $A_2 := \phi(A_1, A_0)$ instead of
% $A_2 := \Phi(A_1, @A_1, A_0, @A_0)$ in {\it partial}
% Array SSA form.  
% A consequence of dropping @ variables is that partial Array
% SSA form does not need to deal with iteration
% vectors, and therefore does not require the control flow
% graph to be {\it reducible} as in full Array SSA form.
% The use of $\phi$ operators without @ variables brings
% partial Array SSA form closer to traditional SSA form.
% The key difference is that partial Array SSA form still contains 
% renamed arrays and definition $\phi$ operators for updates to array elements.

