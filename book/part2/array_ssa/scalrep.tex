
\begin{figure}
{\small
\begin{tabular}[t]{lll}
\begin{minipage}[t]{2.0in}
\setlength{\baselineskip}{10pt}
Original program: \\
%-----------------
\begin{verbatim}
  p  := new Type1
  q  := new Type1
  . . .
 p.x := ...
 q.x := ...
...  := p.x

\end{verbatim} 
\bigskip
After redundant load elimination: \\
%---------------
\begin{verbatim}
  p  := new Type1
  q  := new Type1
  . . .
  T1 := ...
 p.x := T1
 q.x := ...
...  := T1
\end{verbatim} 
\begin{center}
(a)
\end{center}
\end{minipage}
&
\begin{minipage}[t]{2.0in}
\setlength{\baselineskip}{10pt}
Original program: \\
\begin{verbatim}
  p  := new Type1
  q  := new Type1
  . . .
...  := p.x 
 q.x := ...
...  := p.x

\end{verbatim} 
\bigskip
After redundant load elimination: \\
%---------------
\begin{verbatim}
  p  := new Type1
  q  := new Type1
  . . .
  T2 := p.x
...  := T2
 q.x := ...
...  := T2
\end{verbatim} 
\begin{center}
(b)
\end{center}
\end{minipage}
&
\begin{minipage}[t]{2.0in}
\setlength{\baselineskip}{10pt}
Original program: \\
\begin{verbatim}
  p  := new Type1
  q  := new Type1
  r  := p
  . . .
 p.x := ...
 q.x := ...
 r.x := ...
\end{verbatim} 
\bigskip
After dead store elimination: \\
%---------------
\begin{verbatim}
  p  := new Type1
  q  := new Type1
  r  := p
  . . .
 q.x := ...
 r.x := ...

\end{verbatim} 
\begin{center}
(c)
\end{center}
\end{minipage}
\end{tabular}
}
\caption{Examples of scalar replacement}
\label{fig:ex2}
\end{figure}

In this Section, we introduce two new analyses based on Extended
Array SSA form.  These two analyses form the backbone of 
{\em scalar replacement} transformations, which replace accesses
to memory by uses of scalar temporaries.  First, we present an
analysis to identify fully redundant loads.  Then, we present an
analysis to identify dead stores.

Figure~\ref{fig:ex2} illustrates three different cases of scalar
replacement for object fields. 
All three cases can be identified by the algorithms presented in this chapter.
(Similar examples can 
be constructed for scalar replacement of array elements.)
For the original program in figure~\ref{fig:ex2}(a),
introducing a scalar temporary {\tt T1} for the store (def) of {\tt
p.x} can enable the load (use) of {\tt p.x} to be eliminated \ie\ to
be replaced by a use of {\tt T1}.  Figure~\ref{fig:ex2}(b)
contains an example in which a scalar temporary ({\tt T2}) is
introduced for the first load of {\tt p.x}, thus enabling the second
load of {\tt p.x} to be eliminated \ie\ replaced by {\tt T2}.  Finally,
figure~\ref{fig:ex2}(c) contains an example in which the first store of {\tt
p.x} can be eliminated because it is known to be dead (redundant); no
scalar temporary needs to be introduced in this case.

\REM{
The scalar replacement
transformations in Figures~\ref{fig:ex2}(a) and \ref{fig:ex2}(b)
are correct because  {\tt p}
and {\tt q} have 
definitely different ($\DD$) values thus ensuring that the store of {\tt q.x}
does not interfere with {\tt p.x}.  The dead-store elimination in
figure~\ref{fig:ex2}(c) is correct because the values of {\tt p} and
{\tt r} are known to be definitely the same ($\DS$).
}

Past algorithms for scalar replacement (\eg\ \cite{CaCK90,BoGu95})
have been based on data dependence analysis or on exhaustive (dense)
data flow analysis (\eg\ \cite{CaKe94}).  In this section, we show how
Extended Array SSA form, augmented with the \ds\ and \dd\ analysis information
described in section~\ref{svalnum}, can be used to obtain a simple sparse
scalar replacement algorithm.  In addition, the use of SSA form
enables our algorithm to find opportunities for
scalar replacement that are not discovered by past algorithms that
focus exclusively on innermost loops.  

The rest of this section is organized as follows.
Section~\ref{alg} describes our analysis to identify
redundant loads with respect to previous defs and previous uses,
and Section~\ref{store} outlines
our algorithm for dead store elimination.

\REM{
Figure~\ref{fig:overview} shows the high-level structure of our scalar
replacement algorithm, which  builds on the foundations outlined earlier
(heap arrays, Array SSA form, $\DS$ and $\DD$ relations).
It is important to note that
Array SSA form is used for {\it scalar replacement analysis}, but
the scalar replacement
transformations are performed on the original program rather than on
the Array SSA form.  This approach
avoids the need for
removing extraneous $\phi$ functions from the transformed program,
which can be a challenging problem even for scalar variables.
     

The rest of this section provides details of the scalar replacement
analysis performed in step~\ref{item:analysis} of Figure~\ref{fig:overview}.
}
\REM{
Section~\ref{alg} describes our scalar replacement algorithm
for eliminating loads with respect to previous defs and previous uses,
as illustrated by the
examples in figure~\ref{fig:ex2}(b).
Section~\ref{calls} describes how side effects due to calls
are modeled in our approach.
}
