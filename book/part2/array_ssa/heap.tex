In this section, we present a simple, unified approach for the analysis and
optimization of 
object field and array element accesses in strongly typed languages, 
that works in the presence of
object references/pointers.
We show how SSA-based program
analyses developed for scalars and arrays can be extended to
operate on object references in a strongly typed language like Java.
This extension models object references as
indices into hypothetical {\em heap arrays}.
We then present two new sparse analysis
algorithms using
the heap array representation; one identifies redundant loads, and the
other identifies dead stores.
Using strong typing to help disambiguation, these algorithms are
more efficient than equivalent analyses for weakly typed languages.
Using the results of these algorithms, we can perform scalar replacement
transformations to change operations on object fields
and array elements into operations on scalar
variables.  

\subsection{Analysis Framework}\label{model}
\ssainput{part2/array_ssa/model}

\subsubsection{ Definitely-Same and Definitely-Different Analyses for Heap Array Indices}\label{svalnum}
\ssainput{part2/array_ssa/svalnum}

\subsection{Scalar Replacement Algorithms}
\label{scalrep}
\ssainput{part2/array_ssa/scalrep}

\subsubsection{Redundant Load Elimination}
\label{alg}
\ssainput{part2/array_ssa/alg}

\subsubsection{Dead Store Elimination}\label{store}
\ssainput{part2/array_ssa/store}
