In this chapter,
we introduce an Array SSA form 
that captures precise element-level data flow information for array variables, and
coincides with standard SSA form when applied to scalar variables.  
It can also be applied to structures, objects and other variable types
that can be modeled as arrays.
As we will see,  Array SSA form
has a more powerful $\phi$ function than scalar SSA form, since it can
merge values from distinct definitions on an element by element
basis. 
There are several potential uses for Array SSA form in compiler
analysis
and optimization for uniprocessor and multiprocessor systems.
In this chapter, we will use
{\it constant propagation} and
{\it conditional constant propagation} 
as exemplars of program analyses that can be extended to array variables
using Array SSA form, and {\em redundant load elimination} and {\em dead store
elimination} as exemplars of program optimizations that can be extended to array variables and heap objects using Array SSA form.
As with many algorithms based on scalar SSA form, the algorithms presented in this chapter are linear in the size of the Array SSA form representation.
Though Array SSA form can be made manifest at run-time (\eg\ when enabling parallelization via storage duplication~\cite{KnSa98}), all the algorithms described in this chapter  use Array SSA form as a basis
for program analysis, 
which means that the Array SSA form
structures can be removed after the  program properties
of interest
have been discovered.

The rest of the chapter is organized as follows.
Section~\ref{sec:arrayssa} reviews full Array SSA form for run-time
evaluation as in
\cite{KnSa98}, and also introduces partial Array SSA form
for static analysis.  
Section~\ref{sec:arraylattice} describes how we
extend the constant
propagation lattice so that it can efficiently
record information about array
elements.                                       
Section~\ref{sec:sc} presents an extension to the Sparse
Constant propagation (SC) algorithm from \cite{WeZa91} that enables 
constant propagation through array elements.
For simplicity, the algorithm in section~\ref{sec:sc} is restricted
to cases in which both the subscript and the value of an
array definition are constant.
Section~\ref{sec:non-const} generalizes the algorithm from section~\ref{sec:sc} so that it can operate on non-constant (symbolic) array subscripts as well
\eg\ to propagate a def such as $A[m] := 99$ into a use of $A[m]$ even
if $m$ is not a constant.
% Next, section~\ref{sec:scc} presents an extension to the Sparse Conditional
% Constant propagation (SCC) algorithm from \cite{WeZa91} that enables
% constant propagation through array elements in conjunction with 
% unreachable code elimination.
Section~\ref{sec:heap} shows how Array SSA form can be extended to support
analysis and
optimization of 
object field and array element accesses in strongly typed languages,
and section~\ref{sec:conclusions} contains our conclusions.


