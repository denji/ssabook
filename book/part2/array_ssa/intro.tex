In this chapter,
we introduce an Array SSA form 
that captures element-level data flow information for array variables, and
coincides with standard SSA form when applied to scalar variables.  
Any program with arbitrary control flow structures and arbitrary array
subscript expressions can be automatically converted to this 
Array SSA form, thereby making it applicable to structures, heap
objects and any other data structure
that can be modeled as a logical array.
A key extension over standard SSA form is the introduction of a
{\em definition-$\Phi$} function that is capable of
merging values from distinct array definitions on an element-by-element
basis. 
There are several potential applications of Array SSA form in compiler
analysis
and optimization of sequential and parallel programs.
In this chapter, we focus on sequential programs and use
{\em constant propagation}
as an exemplar of a program analysis that can be extended to array variables
using Array SSA form, and {\em redundant load elimination} as an
exemplar  of a program optimization that can be extended to heap objects using Array SSA form.
% As with many algorithms based on scalar SSA form, the algorithms presented in this chapter are linear in the size of the Array SSA form representation.
% Though Array SSA form can be made manifest at run-time (\eg\ when enabling parallelization via storage duplication~\cite{KnSa98}), all the algorithms described in this chapter  use Array SSA form as a basis
% for program analysis, 
% which means that the Array SSA form
% structures can be removed after the  program properties
% of interest
% have been discovered.

The rest of the chapter is organized as follows.
Section~\ref{sec:arrayssa} introduces {\em full Array SSA form} for run-time
evaluation and {\em partial Array SSA form}
for static analysis.  
Section~\ref{sec:cp} extends the scalar SSA
constant propagation algorithm to enable
constant propagation through array elements.
This includes an extension to the constant
propagation lattice to efficiently
record information about array
elements and an extension to the
work-list algorithm to support  {\em definition-$\Phi$} functions (section~\ref{sec:arraylattice}), and
a further extension to support non-constant (symbolic) array
subscripts (section~\ref{sec:non-const}). 
Section~\ref{sec:heap} shows how Array SSA form can be extended to
support elimination of redundant loads of 
object fields and array elements in strongly typed languages,
and section~\ref{sec:conclusions} contains suggestions for further reading.


