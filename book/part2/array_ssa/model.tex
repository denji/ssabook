In this section, we describe a unified representation called
{\em Extended Array SSA} form, which can be used to perform
sparse dataflow analysis of values through scalars, array
elements, and object references.  First, we introduce a
formalism called {\em Heap Arrays} which allows us to represent
object references with the same representation used to
represent named arrays~\cite{FiKS00}.   Then, we show how to use the
Extended Array SSA representation and global value numbering to
disambiguate pointers with the same framework used to analyze
array indices.

\subsubsection{Heap Arrays}\label{heaparray}
\REM{
In this section, we describe our approach to analyzing accesses to
object fields and array elements as accesses to elements of
hypothetical {\it heap arrays}.  
This modeling is only used for
intermediate program analysis; the heap arrays are not made manifest
in the transformed program.  
}
The partitioning of memory locations into
heap arrays is analogous to the partitioning of memory locations using
type-based alias analysis~\cite{DiwanMM1998}.  The main difference is that
our approach also performs a flow-sensitive analysis of
element-level accesses to the heap arrays.
We model accesses to object fields as follows.
For each field $x$, we introduce
a hypothetical one-dimensional
heap array,  $\HA^x$.
Heap array $\HA^x$ consolidates all instances of field
$x$ present in the heap.
Heap arrays are indexed by object references.
Thus, a {\sc getfield}
of $p.x$ is modeled as a read of element $\HA^x[p]$,
and a {\sc putfield} of $q.x$ is modeled as a write of element $\HA^x[q]$.
The use of distinct heap arrays for distinct fields leverages the 
fact that accesses to distinct fields must be directed to 
distinct memory locations in a strongly typed language.
Note that field $x$ is considered to be the same field for objects of types
$C_1$ and $C_2$, if $C_2$ is
a subtype of $C_1$.

Recall that 
arrays in an object-oriented language like Java
are also allocated, so both an object reference and an
integer subscript are necessary for accessing an array element. 
Such arrays can be modeled as {\it two-dimensional} heap
arrays, with one dimension indexed by
the object reference as in heap arrays for fields, and the second
dimension indexed by the integer subscript.  Further details on how 
array objects are handled can be found in \cite{FiKS00}.
% To avoid confusion, we refer to the array declared in the program 
% as a ``program array'', and its representation in our model as 
% its corresponding heap array

Having modeled object and array references as accesses to
named arrays, we can rename heap arrays and scalar variables
to build an extended version of Array SSA form~\cite{KnSa98}.
First, we rename heap arrays so
that each renamed heap array
has a unique static definition.
This includes renaming of the dummy definition 
inserted at the start block to capture the unknown initial value
of the heap array.

We insert three kinds of $\phi$ functions 
to obtain an {\it extended}
Array SSA form that we use for data flow analyses\footnote{The extended
Array SSA form can also be viewed as a
sparse data flow evaluation graph~\cite{ChCF91} for
a heap array.}:
\begin{enumerate}
\item 
A {\em control} $\phi$ from scalar SSA form~\cite{CFRWZ91a}.
\item
A {\em definition} $\phi$ ($d\phi$) from Array SSA form~\cite{KnSa98,KnSa98b}.
\item
A {\em use} $\phi$ ($u\phi$) function creates
a new name whenever a statement reads a heap array element.
$u\phi$ functions represent the extension
in ``extended'' Array SSA form.

\end{enumerate}
The main purpose of the $u\phi$ function is to link
together load instructions for the same heap array in control
flow order.   Intuitively, the $u\phi$ function creates a new
SSA variable name, with which a sparse dataflow analysis can
associate a lattice variable.  We present one dataflow algorithm that 
uses this information for redundant load identification later in 
the chapter.  Other algorithms (eg. constant propagation) will not require a 
new name at each use, in which case the $u\phi$ function can be
ignored.
