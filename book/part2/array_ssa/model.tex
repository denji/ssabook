We introduce a
formalism called {\em heap arrays} which allows us to model
object references as associative arrays.   
An {\em extended Array SSA} form is constructed on heap arrays by
adding
{\em use-$\phi$} functions.
% The partitioning of memory locations into
% heap arrays is analogous to the partitioning of memory locations using
% type-based alias analysis.  The main difference is that
% our approach also performs a flow-sensitive analysis of
% element-level accesses to the heap arrays.
% We model accesses to object fields as follows.
For each field $x$, we introduce
a hypothetical one-dimensional
heap array,  $\HA^x$.
Heap array $\HA^x$ consolidates all instances of field
$x$ present in the heap.
Heap arrays are indexed by object references.
Thus, a {\sc getfield}
of $p.x$ is modeled as a read of element $\HA^x[p]$,
and a {\sc putfield} of $q.x$ is modeled as a write of element $\HA^x[q]$.
The use of distinct heap arrays for distinct fields leverages the 
fact that accesses to distinct fields must be directed to 
distinct memory locations in a strongly typed language.
Note that field $x$ is considered to be the same field for objects of types
$C_1$ and $C_2$, if $C_2$ is
a subtype of $C_1$.
Accesses to one-dimensional array objects with the same element type
are modeled as accesses to a single {\it two-dimensional} heap
array for that element type, with one dimension indexed by
the object reference as in heap arrays for fields, and the second
dimension indexed by the integer subscript. 
% To avoid confusion, we refer to the array declared in the program 
% as a ``program array'', and its representation in our model as 
% its corresponding heap array

% Having modeled object and array references as accesses to
% named arrays, we can rename heap arrays and scalar variables
% to build an extended version of Array SSA form.
% First, we rename heap arrays so
% that each renamed heap array
% has a unique static definition.
% This includes renaming of the dummy definition 
% inserted at the start block to capture the unknown initial value
% of the heap array.

Heap arrays are renamed in accordance with 
an {\it extended}
Array SSA form that contains three kinds of $\phi$ functions:
\begin{enumerate}
\item 
A {\em control} $\phi$ from scalar SSA form.
\item
A {\em definition} $\phi$ ($d\phi$) from Array SSA form.
\item
A {\em use} $\phi$ ($u\phi$) function creates
a new name whenever a statement reads a heap array element.
$u\phi$ functions represent the extension
in ``extended'' Array SSA form.
\end{enumerate}
The main purpose of the $u\phi$ function is to link
together load instructions for the same heap array in control-flow order.   While $u\phi$ functions are used by the redundant load
elimination optimization presented in this chapter, it is not
necessary for analysis algorithms (\eg\ constant propagation) that do not require the creation of
a 
new name at each use.
