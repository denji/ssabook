% Bibliography file for "Graphs and gating functions"
% Authors: James Stanier
% Last updated: 7/8/09

% ==============
% Control flow graph
% ==============

@article{808479,
 author = {Allen, Frances E.},
 title = {Control flow analysis},
 journal = {SIGPLAN Not.},
 volume = {5},
 number = {7},
 year = {1970},
 issn = {0362-1340},
 pages = {1--19},
 doi = {http://doi.acm.org/10.1145/390013.808479},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

% =======================
% Click's simple IR publications
% =======================

% SIGPLAN Notices article
@article{202534,
 author = {Click, Cliff and Paleczny, Michael},
 title = {A simple graph-based intermediate representation},
 journal = {SIGPLAN Not.},
 volume = {30},
 number = {3},
 year = {1993},
 issn = {0362-1340},
 pages = {35--49},
 doi = {http://doi.acm.org/10.1145/202530.202534},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

% ==============================
% Gated Single Assignment publications
% ==============================

% Construction of Thinned Gated Single-Assignment Form.
@INPROCEEDINGS{Havlak93constructionof,
    author = {Paul Havlak},
    title = {Construction of Thinned Gated Single-Assignment Form},
    booktitle = {In Proc. 6rd Workshop on Programming Languages and Compilers for Parallel Computing},
    year = {1993},
    pages = {477--499},
    publisher = {Springer Verlag}
}

% Efficient building and placing of gating functions.
@inproceedings{207115,
 author = {Tu,, Peng and Padua,, David},
 title = {Efficient building and placing of gating functions},
 booktitle = {PLDI '95: Proceedings of the ACM SIGPLAN 1995 conference on Programming language design and implementation},
 year = {1995},
 isbn = {0-89791-697-2},
 pages = {47--55},
 location = {La Jolla, California, United States},
 doi = {http://doi.acm.org/10.1145/207110.207115},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

% Program Dependence Web -- used GSA form in translation.
@inproceedings{93578,
 author = {Ottenstein,, Karl J. and Ballance,, Robert A. and MacCabe,, Arthur B.},
 title = {The program dependence web: a representation supporting control-, data-, and demand-driven interpretation of imperative languages},
 booktitle = {PLDI '90: Proceedings of the ACM SIGPLAN 1990 conference on Programming language design and implementation},
 year = {1990},
 isbn = {0-89791-364-7},
 pages = {257--271},
 location = {White Plains, New York, United States},
 doi = {http://doi.acm.org/10.1145/93542.93578},
 publisher = {ACM},
 address = {New York, NY, USA},
 }
 
% ==============================
%              VSDG publications
% ==============================

% Value Dependence Graph
@inproceedings{177907,
 author = {Daniel Weise and Roger F. Crew and Michael Ernst and Bjarne Steensgaard},
 title = {Value dependence graphs: representation without taxation},
 booktitle = {POPL '94: Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
 year = {1994},
 isbn = {0-89791-636-0},
 pages = {297--310},
 location = {Portland, Oregon, United States},
 doi = {http://doi.acm.org/10.1145/174675.177907},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

% Neil Johnson's thesis.
@TechReport{UCAM-CL-TR-607,
  author =	 {Johnson, Neil E.},
  title = 	 {{Code size optimization for embedded processors}},
  year = 	 2004,
  month = 	 nov,
  url = 	 {http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-607.pdf},
  institution =  {University of Cambridge, Computer Laboratory},
  issn = 	 {1476-2986},
  abstract = 	 {This thesis studies the problem of reducing code size
            	  produced by an optimizing compiler. We develop the Value
            	  State Dependence Graph (VSDG) as a powerful intermediate
            	  form. Nodes represent computation, and edges represent
            	  value (data) and state (control) dependencies between
            	  nodes. The edges specify a partial ordering of the
            	  nodes---sufficient ordering to maintain the I/O semantics
            	  of the source program, while allowing optimizers greater
            	  freedom to move nodes within the program to achieve
            	  better (smaller) code. Optimizations, both classical and
            	  new, transform the graph through graph rewriting rules
            	  prior to code generation. Additional (semantically
            	  inessential) state edges are added to transform the VSDG
            	  into a Control Flow Graph, from which target code is
            	  generated.
            	  
            	  We show how procedural abstraction can be advantageously
            	  applied to the VSDG. Graph patterns are extracted from a
            	  program's VSDG. We then select repeated patterns giving
            	  the greatest size reduction, generate new functions from
            	  these patterns, and replace all occurrences of the
            	  patterns in the original VSDG with calls to these
            	  abstracted functions. Several embedded processors have
            	  load- and store-multiple instructions, representing
            	  several loads (or stores) as one instruction. We present
            	  a method, benefiting from the VSDG form, for using these
            	  instructions to reduce code size by provisionally
            	  combining loads and stores before code generation. The
            	  final contribution of this thesis is a combined register
            	  allocation and code motion (RACM) algorithm. We show that
            	  our RACM algorithm formulates these two previously
            	  antagonistic phases as one combined pass over the VSDG,
            	  transforming the graph (moving or cloning nodes, or
            	  spilling edges) to fit within the physical resources of
            	  the target processor.
            	  
            	  We have implemented our ideas within a prototype C
            	  compiler and suite of VSDG optimizers, generating code
            	  for the Thumb 32-bit processor. Our results show
            	  improvements for each optimization and that we can
            	  achieve code sizes comparable to, and in some cases
            	  better than, that produced by commercial compilers with
            	  significant investments in optimization technology.},
  number = 	 {UCAM-CL-TR-607}
}

@INPROCEEDINGS{Johnson_combinedcode,
author = {Neil Johnson and Alan Mycroft},
title = {Combined Code Motion and Register Allocation using the Value State Dependence Graph},
booktitle = {In Proc. 12th International Conference on Compiler Construction (CC’03) (April 2003},
year = {},
pages = {1--16}
}


% Combined code motion and register allocation paper.
@inproceedings{johnson-combined,
  author = "Neil Johnson and Alan Mycroft",
  title = "Combined Code Motion and Register Allocation using the Value State Dependence
    Graph",
  booktitle = "Proc. 12th International Conference on Compiler Construction (CC 2003)",
  year = "2003",
  editor = "Gorel Hedin",
  volume = "LNCS 2622",
  pages = "1--16",
  series = "Lecture Notes in Computer Science",
  address = "Warsaw, Poland",
  month = "April",
  publisher = "Springer-Verlag",
 }

% Eben Upton's thesis.
@misc{upton,
       author = "Eben Upton",
       title = "Compiling with Data Dependence Graphs",
       institution =  {University of Cambridge, Computer Laboratory},
       year = "2006" }

% NP-Complete split-node insertion.
@inproceedings{DBLP:conf/pdpta/Upton03,
  author    = {Eben Upton},
  title     = {Optimal Sequentialization of Gated Data Dependence Graphs
               is NP-Complete},
  booktitle = {PDPTA},
  year      = {2003},
  pages     = {1767-1770},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

% Alan Lawrence's thesis.
 @TechReport{UCAM-CL-TR-705,
  author =	 {Lawrence, Alan C.},
  title = 	 {{Optimizing compilation with the Value State Dependence
         	   Graph}},
  year = 	 2007,
  month = 	 dec,
  url = 	 {http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-705.pdf},
  institution =  {University of Cambridge, Computer Laboratory},
  issn = 	 {1476-2986},
  abstract = 	 {Most modern compilers are based on variants of the
            	  Control Flow Graph. Developments on this
            	  representation---specifically, SSA form and the Program
            	  Dependence Graph (PDG)---have focused on adding and
            	  refining data dependence information, and these suggest
            	  the next step is to use a purely data-dependence-based
            	  representation such as the VDG (Ernst et al.) or VSDG
            	  (Johnson et al.).
            	  
            	  This thesis studies such representations, identifying key
            	  differences in the information carried by the VSDG and
            	  several restricted forms of PDG, which relate to
            	  functional programming and continuations. We unify these
            	  representations in a new framework for specifying the
            	  sharing of resources across a computation.
            	  
            	  We study the problems posed by using the VSDG, and argue
            	  that existing techniques have not solved the
            	  sequentialization problem of mapping VSDGs back to CFGs.
            	  We propose a new compiler architecture breaking
            	  sequentialization into several stages which focus on
            	  different characteristics of the input VSDG, and tend to
            	  be concerned with different properties of the output and
            	  target machine. The stages integrate a wide variety of
            	  important optimizations, exploit opportunities offered by
            	  the VSDG to address many common phase-order problems, and
            	  unify many operations previously considered distinct.
            	  
            	  Focusing on branch-intensive code, we demonstrate how
            	  effective control flow---sometimes superior to that of
            	  the original source code, and comparable to the best CFG
            	  optimization techniques---can be reconstructed from just
            	  the dataflow information comprising the VSDG. Further, a
            	  wide variety of more invasive optimizations involving the
            	  duplication and specialization of program elements are
            	  eased because the VSDG relaxes the CFG's
            	  overspecification of instruction and branch ordering.
            	  Specifically we identify the optimization of nested
            	  branches as generalizing the problem of minimizing
            	  boolean expressions.
            	  
            	  We conclude that it is now practical to discard the
            	  control flow information rather than maintain it in
            	  parallel as is done in many previous approaches (e.g. the
            	  PDG).},
  number = 	 {UCAM-CL-TR-705}
}