\chapter{Psi-SSA Form \Author{F. de Ferri\`ere}}
\inputprogress

\section{Overview}

% Explain why SSA renaming cannot be applied on predicated definitions. 

% The $\psi$-SSA representation was developed to extend the SSA
% representation with support for predicated operations.

In the SSA representation, each definition of a variable is given a
unique name, and new pseudo definitions are introduced on $\phi$
functions to merge values coming from different control-flow paths. An
example is given figure~\ref{fig:op_ssa}. Each definition is an
unconditional definition, and the value of a variable is the value of
the expression on the unique assignment to this variable. This
essential property of the SSA representation does not any longer hold
when definitions may be conditionally executed. When the definition
for a variable is a predicated operation, the value of the variable
will or will not be modified depending on the value of a guard
register. As a result, the value of the variable after the predicated
operation is either the value of the expression on the assignment if
the predicate is true, or the value the variable had before this
operation if the predicate is false. We need a way to express these
conditional definitions whilst keeping the static single assignment
property.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt a = op1}$ & & & ${\tt a_1 = op1$ \\
${\tt if (p)}$        & & & \\
${\tt\ \ \ \ \ a = op2;}$ & & & ${\tt \ \ \ \ \ a_2 = op2;}$ \\
& & & ${\tt a_3 = Phi(a_1, a_2)}$ \\
${\tt \ = a}$ & & & ${\tt \ = a_3}$ \\
\end{tabular}
\caption{SSA representation}
\label{fig:op_ssa}
\end{center}
\end{figure}

\section{Definition and Construction}

\textbf{1 page}

% Gives the semantics of the PSI function, doing the parallel with PHI
% function before if-conversion. Explain the relation between the
% predicates on the definition and the predicates in the PSI. Explain
% how a PSI function is executed.

Predicated operations are used to remove control-flow instructions.
These instructions may be present in the intermediate representation
as a result of inlining of assembly code. The compiler may also
generate these operations by performing an if-conversion
optimization~\ref{chap:if-conversion} that removes control-flow
operations and replaces conditionnaly executed code by predicated
instructions.

This is illustrated in figure~\ref{fig:op_pred0}. We use the notation
{\tt p? a = op} to indicate that the operation {\tt a = op} is
executed only if predicate {\tt p} is true, and is ignored
otherwise. We will also use the notation ${\tt \overline{p}}$ to refer
to the complement of predicate {\tt p}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt a_1 = op1}$ & & & ${\tt a_1 = op1$ \\
${\tt if (p)}$        & & & \\
${\tt\ \ \ \ \ a_2 = op2;}$ & \ \ \ \ \  & ${\tt p?}$ & ${\tt a_2 = op2;}$ \\
${\tt a_3 = Phi(a_1, a_2)}$ & & & \\
${\tt \ = a_3}$ & & & ${\tt \ = a??}$ \\
\end{tabular}
\caption{SSA on predicated code}
\label{fig:op_pred0}
\end{center}
\end{figure}

On this example, the use of {\tt a} on the last instruction refers to
the variable ${\tt a_1}$ if {\tt p} is false, or to the variable ${\tt
  a_2}$ if {\tt p} is true. These multiple reaching definitions on the
use of {\tt a} cannot be represented by the standard SSA
representation.

One possible representation would be to use the Gated SSA form,
presented in Chapter~\ref{chap:vsdg}. In such a representation, the
$\phi$ function would be augmented with the predicate {\tt p} to tell
wich value between ${\tt a_1}$ and ${\tt a_2}$ is to be
considered. However, Gated SSA is a completely different intermediate
representation where the control-flow is no longer represented. This
representation is more suited for program interpretation or hardware
synthesis, SSA algorithm for optimizations and code generations cannot
be direclty applied.

Another possible representation would be to add a reference to ${\tt
  a_1}$ on the definition of ${\tt a_2}$. Now, ${\tt a_2}$ holds the
value of ${\tt a_1}$ if {\tt p} is false, or the value of ${\tt op2}$
if {\tt p} is true. The use of {\tt a} on the last instruction now
refers to the variable ${\tt a_2}$, which holds the correct value. The
drawback of this representation is that it adds dependencies between
operations, which will prevent code reordering for scheduling. It will
also create useless dependencies when there are definitions on
disjoints predicates that will be difficult to ignore or remove.

Our solution is presented in figure~\ref{fig:op_pred}. The $\phi$
function is replaced by a $\psi$ function, with information on the
predicate associated with each argument. This representation is
adpated to code optimization and code generation on a low-level
intermediate representation.

A $\psi$ function is written ${\tt a_0 = Psi(p_1?a_1, p_2?a_2, ...,
  p_n?a_n)}$. A $\psi$ function defines one variable, ${\tt a_0}$, and
takes a variable number of arguments ${\tt a_i}$. Each argument is
associated with a predicate ${\tt p_i}$. In the notation, the
predicate ${\tt p_i}$ associated with an argument ${\tt a_i}$ will be
omitted if ${\tt p_i \equiv true}$.

A $\psi$ function has the following properties:

\begin{itemize}

\item{\emph{It is an operation}} A $\psi$ function is a regular operation. It
  can occur at any location in a basic block where a regular operation
  is valid. Each argument ${\tt a_i}$, and each predicate ${\tt p_i}$,
  must be dominated by its definition.

\item{\emph{It is predicated}} A $\psi$ function is a predicated
  operation, under the predicate ${\tt \bigcup_{k=1}^n p_k}$,
  althought this predicate is not explicit in the representation.

\item{\emph{It has an ordered list of arguments}} The order of the
  arguments in a $\psi$ function is significant. A $\psi$ function is
  evaluated from left to right. The value of a $\psi$ function is the
  value of the right most argument whose predicate is true.

\item{\emph{Rule on predicates}} The predicate ${\tt p_i}$ associated
  with the argument ${\tt a_i}$ in a $\psi$ function must be included
  in or equal to the predicate on the definition of the variable ${\tt
    a_i}$.
\begin{tabular}{ll}
\multicolumn{2}{l}{\it for the instructions}\\
${\tt p?}$ & ${\tt a_i = ...}$\\
& ${\tt a_0 = Psi(..., p_i?a_i, ...)}$\\
\multicolumn{2}{l}{\it then}\\
& ${\tt p_i} \subseteq {\tt p}$\\
\end{tabular}

\end{itemize}

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt a_1 = op1}$ & & & ${\tt a_1 = op1$ \\
${\tt if (p)}$        & & & \\
${\tt\ \ \ \ \ a_2 = op2;}$ & \ \ \ \ \  & ${\tt p?}$ & ${\tt a_2 = op2;}$ \\
${\tt a_3 = Phi(a_1, a_2)}$ & & & ${\tt a_3 = Psi(a_1, p?a_2)}$ \\
${\tt \ = a_3}$ & & & ${\tt \ = a_3}$ \\
\end{tabular}
\caption{$\psi$-SSA representation}
\label{fig:op_pred}
\end{center}
\end{figure}

A $\psi$ function can represent cases where variables are defined on
predicates that are computed from independent conditions. This is
illustrated in figure~\ref{fig:non_disjoint_pred}, where the
predicates {\tt p} and {\tt q} are independent. During the SSA
construction a unique variable {\tt a} was renamed into the variables
${\tt a_1}$, ${\tt a_2}$ and ${\tt a_3}$ and the variables ${\tt x_1}$
and ${\tt x_2}$ were introduced to merge values coming from different
control-flow paths. In the non-predicated code, there is a
control-dependency between ${\tt x_1}$ and ${\tt a_3}$, which means
the definition of ${\tt a_3}$ must be executed after the value for
${\tt x_1}$ has been computed. In the predicated form of this example,
there is no longer any control dependencies between the definitions of
${\tt a_1}$, ${\tt a_2}$ and ${\tt a_3}$. A compiler transformation
can now freely move these definitions independently of each other,
which may allow more optimizations to be performed on this
code. However, the semantics of the original code requires that the
definition of ${\tt a_3}$ occurs after the definitions of ${\tt a_1}$
and ${\tt a_2}$. The order of the arguments in a $\psi$ function gives
information on the original order of the definitions. We take the
convention that the order of the arguments in a $\psi$ function is,
from left to right, equal to the original order of their definitions,
from top to bottom, in the control-flow dominance tree of the program
in a non-SSA representation. This information is needed to maintain
the correct semantics of the code during transformations of the
$\psi$-SSA representation and to revert the code back to a non
$\psi$-SSA representation.

%An important property of the SSA, and $\psi$-SSA, representation is
%that every use of a variable is dominated by the unique definition for
%this variable.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt if (p)}$        & & & \\
${\tt\ \ \ \ \ a_1 = 1;}$ & \ \ \ \ \  & ${\tt p?}$ & ${\tt a_1 = 1;}$ \\
${\tt else}$          & & & \\
${\tt\ \ \ \ \     a_2 = -1;}$ & \ \ \ \ \  & ${\tt \overline{p}?}$ & ${\tt a_2 = -1;}$ \\
${\tt x_1 = Phi(a_1, a_2)}$ & & & ${\tt x_1 = Psi(p?a_1, \overline{p}?a_2)}$ \\
${\tt if (q)}$        & & & \\
${\tt\ \ \ \ \ a_3 = 0;}$ & \ \ \ \ \  & ${\tt q?}$ & ${\tt a_3 = 0;}$ \\
${\tt x_2 = Phi(x_1, a_3)}$ & & & ${\tt x_2 = Psi(p?a_1, \overline{p}?a_2, q?a_3)}$ \\
\end{tabular}
\caption{$\psi$-SSA with non-disjoint predicates}
\label{fig:non_disjoint_pred}
\end{center}
\end{figure}


% Explain how PSI instructions are built, either during the SSA
% construction on predicated instructions, or during if-conversion
% under SSA by converting PHI functions into PSI functions.

The construction of the $\psi$-SSA representation is a small
modification on the standard algorithm to built an SSA representation.

The insertion of $\psi$ functions is performed in the SSA renaming
phase of a classical SSA construction algorithm, described
in~\ref{chap:classical_construction}.

During the SSA renaming phase, basic blocks are processed in their
dominance order, and operations in each basic block are scanned from
top to bottom. On an operation, for each predicated definition of a
variable, a new $\psi$ function will be inserted just after the
operation. For the definition of a variable {\tt x} under predicate
{\tt p}, the $\psi$ function will take the form ${\tt x = Psi(p?x_1,
  p?x)}$, where ${\tt x_1}$ is the current renaming of {\tt x} before
the definition, and {\tt p} is the predicate used on the definition of
${\tt x_1}$. Once this instruction is inserted, the normal renaming of
the operation proceeds, renaming {\tt x} into a new name ${\tt
  x_2}$. When the renaming of the operation is completed, the
algorithm continues on the next instruction, which will be a $\psi$
function if there was a predicated definition. The first argument of
the $\psi$ function is already renamed and thus is not modified. The
second argument is xrenamed into the current renaming for {\tt x}
which is ${\tt x_2}$. On the definition of the $\psi$ function, the
variable {\tt x} is given a new name, ${\tt x_3}$, which becomes the
renaming for further references to the {\tt x} variable. This
insertion and renaming of a $\psi$ function is shown on
figure~\ref{fig:psi_ssa_construct}

$\psi$ functions can also be introduced in an SSA representation by
applying an if-conversion transformation, such as the one that is
described in~\ref{chap:if-conversion}. Local transformations on
control-flow patterns can also require to replace $\phi$ functions by
$\psi$ functions.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llllllllll}
${\tt p?}$ & ${\tt x = op}$ & \ \ \ \  & ${\tt p?}$ & ${\tt x = op}$           & \ \ \ \  & ${\tt p?}$ & ${\tt x_2 = op}$           & \ \ \ \  & ${\tt p?}$ & ${\tt x_2 = op}$ \\
           &                &          &            & ${\tt x = psi(x_1, p?x}$ &           &           & ${\tt x = psi(x_1, p?x_2)}$ &          &           & ${\tt x_3 = psi(x_1, p?x_2)}$ \\
\end{tabular}
\caption{Construction and renaming of $\psi$-SSA}
\label{fig:psi_ssa_construct}
\end{center}
\end{figure}


\section{SSA algorithms}

\textbf{1 page}

% Explain how standard SSA algorithm can be adapted to the Psi-SSA
% form: Predicated definitions are now seen as non-predicated ones,
% and a semantics, similar to the similar of PHI functions, must be
% defined for PSI functions.

With this definition of the $\psi$-SSA representation, conditional
definitions on predicated code are now replaced by unconditional
definitions on $\psi$ functions. Usual algorithms that perform
optimizations or transformations on the SSA representation can now be
easily adapted to the $\psi$-SSA representation, without compromising
the efficiency of the transformations performed. Actually, within the
$\psi$-SSA representation, predicated definitions behave exactly the
same as non predicated ones for optimizations on the SSA
representation. Only the $\psi$ functions have to be treated in a
specific way. As an example, the constant propagation algorithm
described in~\cite{WZ91} can be easily adapted to the $\psi$-SSA
representation. In this algorithm, the only modification is that
$\psi$ functions have to be handled with the same rules as the $\phi$
functtions. Other algorithms such as dead code
elimination~\cite{morgan98}, global value numbering~\cite{Cli95},
partial redundancy elimination~\cite{CCK+97}, and induction variable
analysis~\cite{Wolfe92} are examples of algorithm that can easily be
adapted to this representation.

\section{Psi-SSA algorithms}

\textbf{3 page}

% Special transformations can be applied on Psi-SSA, which allows to
% optimize predicated code. Explain on an example what are the uses of
% inlining, reduction, projection and predicate promotion.

In addition to standard algorithms that can be applied to $\psi$
functions and predicated code, a number of specific transformations
can be performed on the $\psi$ functions : $\psi$-inlining,
$\psi$-reduction, $\psi$-projection, $\psi$-permutation and
$\psi$-promotion.

\begin{itemize}

\item{\emph{$\psi$-inlining}} will recursively replace in a $\psi$
  function an argument that is defined on another $\psi$ function by
  the arguments of this other $\psi$ function. This is shown in
  figure~\ref{fig:psi_inlining}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
             & ${\tt a_1 = op_1}$             & \ \ \ \  &             & ${\tt a_1 = op_1}$ \\
${\tt p_2?}$ & ${\tt a_2 = op_2}$             & \ \ \ \  & ${\tt p_2?}$ & ${\tt a_2 = op_2}$ \\
             & ${\tt x_1 = Psi(a_1, p_2?a_2)}$ & \ \ \ \  &             & ${\tt x_1 = Psi(a_1, p_2?a_2) // dead}$ \\
${\tt p_3?}$ & ${\tt a_3 = op_3}$              & \ \ \ \  & ${\tt p_3?}$ & ${\tt a_3 = op_3}$ \\
             & ${\tt x_2 = Psi(x_1, p_3?a_3)}$ & \ \ \ \  &              &${\tt x_2 = Psi(a_1, p_2?a_2, p_3?a_3)}$ \
\end{tabular}
\caption{$\psi$-inlining}
\label{fig:psi_inlining}
\end{center}
\end{figure}


\item{\emph{$\psi$-reduction}} will remove from a $\psi$ function an
  argument whose value will always be overridden by arguments on its
  right in the argument list. An argument ${\tt a_i}$ associated with
  predicate ${\tt p_i}$ can be removed if ${\tt p_i \subseteq
    \bigcup_{k=i+1}^n p_k}$. This is shown in
  figure~\ref{fig:psi_reduction}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
             & ${\tt a_1 = op_1}$             & \ \ \ \  &             & ${\tt a_1 = op_1}$ \\
${\tt p_2?}$ & ${\tt a_2 = op_2}$             & \ \ \ \  & ${\tt p_2?}$ & ${\tt a_2 = op_2}$ \\
${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$              & \ \ \ \  & ${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$ \\
             & ${\tt x_2 = Psi(a_1, p_2?a_2, \overline{p_2}?a_3)}$ & \ \ \ \  &              &${\tt x_2 = Psi(p_2?a_2, \overline{p_2}?a_3)}$ \\
\end{tabular}
\caption{$\psi$-reduction}
\label{fig:psi_reduction}
\end{center}
\end{figure}

\item{\emph{$\psi$-projection}} will create from a $\psi$ function new
  $\psi$ functions for uses in operations predicated under different
  predicates. Each new $\psi$ function is created as the projection on
  a given predicate of the original $\psi$ function. In this new
  $\psi$ function, arguments whose associated predicate has a domain
  that is disjoint with the domain of the predicate on which the
  projection is performed actually contribute no value to the $\psi$
  function and thus are removed. This is shown in
  figure~\ref{fig:psi_projection}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
${\tt p_2?}$ & ${\tt a_2 = op_2}$             & \ \ \ \  & ${\tt p_2?}$ & ${\tt a_2 = op_2}$ \\
${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$              & \ \ \ \  & ${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$ \\
             & ${\tt x_2 = Psi(p_2?a_2, \overline{p_2}?a_3)}$ & \ \ \ \  &              &${\tt x_2 = Psi(p_2?a_2, \overline{p_2}?a_3)}$ \\
             &                               & \ \ \ \  &              & ${\tt x_3 = Psi(p_2?a_2)}$ \\
${\tt p_2?}$ & ${\tt y_1 = x_2}$              & \ \ \ \  & ${\tt p_2?}$ & ${\tt y_1 = x_3}$ \\
\end{tabular}
\caption{$\psi$-projection}
\label{fig:psi_projection}
\end{center}
\end{figure}

\item{\emph{$\psi$-permutation}} will change the order of the
  arguments in a $\psi$ function. In a $\psi$ function the order of
  the arguments is significant, and we will see that for the
  destruction of the $\psi$-SSA representation this order from left to
  right must be the same as the dominance order from top to bottom of
  the definitions of these arguments. After code motion or copy
  propagation, the dominance order of the definitions of $\psi$
  arguments may be changed. Two arguments in a $\psi$ function can be
  permuted if the intersection of their associated predicate in the
  $\psi$ argument list is empty. An example of such a permutation is
  shown on figure~\ref{fig:psi_permutation}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$              & \ \ \ \  & ${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$ \\
${\tt p_2?}$ & ${\tt a_2 = op_2}$             & \ \ \ \  & ${\tt p_2?}$ & ${\tt a_2 = op_2}$ \\
             & ${\tt x_2 = Psi(p_2?a_2, \overline{p_2}?a_3)}$ & \ \ \ \  &              &${\tt x_2 = Psi(\overline{p_2}?a_3, p_2?a_2)}$ \\
\end{tabular}
\caption{$\psi$-permutation}
\label{fig:psi_permutation}
\end{center}
\end{figure}

%% In this case, as a result of speculation performed
%% during an if-conversion algorithm, the guard used on the definition of
%% a variable may be larger than the guard associated with this variable
%% in a $\psi$ operation. Speculation may be performed because some
%% operations cannot be predicated. Speculation may also be performed as
%% an optimization to reduce the number of guards on predicated code and
%% to reduce the number of operations to compute these guards.

\item{\emph{$\psi$-promotion}} will change the predicates used in a
  $\psi$ function. The $\psi$-SSA representation can be used on a
  partially predicated architecture, where only a subset of the
  instructions supports a predicate operand.
  Figure~\ref{fig:psi_partial} shows an example where some code with
  control-flow edges was transformed into a linear sequence of
  instructions.

On an architecture where the {\tt ADD} operation cannot be predicated,
the {\tt ADD} operation has been speculated under the {\tt true}
predicate. However, the information represented in the $\phi$ function
by the control-flow edges is now present in the $\psi$ function by
means of predicates.

On an architecture where the {\tt ADD} operation can be predicated, it
may also be profitable to perform speculation in order to reduce the
number of predicates on predicated code and to reduce the number of
operations to compute these predicates. Using the representation in
figure~\ref{fig:psi_partial} b), there can be one predicate associated
with the definition of a variable, and there will be one predicate
associated with the use of the variable in a $\psi$ function.

Once speculation has been performed on the definition of a variable
used in a $\psi$ function, the predicate associated with this
argument can be promoted, without changing the semantics of the $\psi$
function. By predicate promotion, we mean that a predicate can be
replaced by a predicate with a larger predicate domain. This promotion
must obey the following condition so that the semantics of the $\psi$
function after the transformation is valid and unchanged :

\begin{tabular}{ll}
\multicolumn{2}{l}{\it for an instruction} \\
\ \ \ \ & {$ {\tt y = Psi(p_1?x_1, p_2?x_2, ..., p_i?x_i, ..., p_n?x_n)}$} \\
\multicolumn{2}{l}{\it transformed to} \\
\ \ \ \ & {$ {\tt y = Psi(p_1?x_1, p_2?x_2, ..., p_i'?x_i, ..., p_n?x_n)}$} \\
\multicolumn{2}{l}{\it then} \\
\ \ \ \ & {${\tt p_i' \subseteq \bigcup_{k=i}^n p_k}$} \\

This promotion must also satisfies the properties of $\psi$
functions, and in particular, that the predicate associated with a
variable in a $\psi$ function must be included in or equal to the
predicate on the definition of that variable. This promotion will not
change the predicate of a $\psi$ function, defined as ${\tt
  \bigcup_{k=1}^n p_k}$.

\begin{figure*}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt if (p)}$                & & & \\
${\tt\ \ \ \ \ a = ADD\ i,1;}$ & \ \ \ \ \ \ \ \  & \ \ \ \ \ \ \ \  & ${\tt a = ADD\ i,1;}$ \\
${\tt else}$                  & \ \ \ \ \ \ \ \  & \ \ \ \ \ \ \ \  & \\
${\tt\ \ \ \ \ b = ADD\ i,2;}$ & \ \ \ \ \ \ \ \  & \ \ \ \ \ \ \ \  & ${\tt b = ADD\ i,2;}$ \\
${\tt x = Phi(a, b)}$         & \ \ \ \ \ \ \ \  & \ \ \ \ \ \ \ \  & ${\tt x = Psi(p?a, \overline{p}?b)}$ \\
\\
\\
\multicolumn{2}{l}{${\tt{\bf a)\ before\ if-conversion}}$} & \multicolumn{2}{l}{${\tt{\bf b)\ Psi\ operation}}$} \\
\end{tabular}
\caption{Psi-SSA for partial predication}
\label{fig:psi_partial}
\end{center}
\end{figure*}

% The two domains for these two predicates do not need to be equal,
% only the domain of the predicate on the definition has to contain
% the domain of the predicate on the $\psi$ argument.

% True only if the predicate domain of the $\psi$ operation is 1.

%% \begin{itemize}

%% \item {\bf Condition 1} For an argument in a $\psi$ operation, the
%% domain of the predicate used on the definition of this argument must
%% contain the domain of the new predicate associated with this argument.

%% \begin{tabular}{ll}
%% \multicolumn{2}{l}{\it for the instructions}\\
%% ${\tt p?}$ & ${\tt x = ...}$\\
%% & ${\tt y = Psi(..., q? x, ...)}$\\
%% \multicolumn{2}{l}{\it then}\\
%% & {${\tt q} \subseteq {\tt p}$}\\
%% \end{tabular}

%% \item {\bf Condition 2} For an argument in a $\psi$ operation, the
%% domain of the new predicate associated with it can be extended up to
%% include the domains of the predicates associated with arguments in the
%% $\psi$ operation that were defined after the definition for this
%% argument in the original program.

%% \begin{tabular}{ll}
%% \multicolumn{2}{l}{\it for an instruction} \\
%% \ \ \ \ & {$ {\tt y = Psi(p_1?x_1, p_2?x_2, ..., p_i?x_i, ..., p_n?x_n)}$} \\
%% \multicolumn{2}{l}{\it transformed to} \\
%% \ \ \ \ & {$ {\tt y = Psi(p_1?x_1, p_2?x_2, ..., p_i'?x_i, ..., p_n?x_n)}$} \\
%% \multicolumn{2}{l}{\it then} \\
%% \ \ \ \ & {${\tt p_i' \subseteq \bigcup_{k=i}^n p_k}$} \\
%% \end{tabular}

%% \end{itemize}

Usually, the first argument of a $\psi$ function can be promoted
under the {\tt true} predicate. Also, when disjoint conditions are
computed, one of them can be promoted to include the other conditions,
usually reducing the number of predicates. A side effect of this
transformation is that it may increase the number of copy instructions
to be generated during the $\psi$-SSA destruction phase, because of
more live-range interference between arguments in a $\psi$ function,
as will be explained in next section~\ref{sec:Psi_ssa_destruction}.

\end{itemize}

\section{Psi-SSA destruction}
\label{sec:Psi_ssa_destruction}

\textbf{3 page}

% Explain what must be done to go out of Psi-SSA. First,
% Psi-normalization must be performed, then live-analysis can be run
% and an interference graph with exact interfences on Psi operations
% can be built. Explain how to repair the interferences and how to
% integrate this algorithm into a standard SSA algorithm.

The SSA destruction phase reverts an SSA representation into a non-SSA
representation. This phase must be adapted to the $\psi$-SSA
representation. The algorithm we present here is derived from the SSA
destruction algorithm from Sreedhar et
al.~\ref{chap:alternative_destruction}.

This algorithm uses $\psi$-SSA webs to create a conventional
$\psi$-SSA representation. We define the conventional $\psi$-SSA ({\em
  $\psi$-CSSA}) form in a similar way to the Sreedhar definition of
the conventional SSA ({\em CSSA}) form. The $\psi$-SSA web definition
is an extention of the SSA web to include $\psi$ funcions. An
$\psi$-SSA web is a non empty, minimal, set of variables such that if
two variables are referenced on the same $\phi$ or $\psi$ function
then they are in the same $\psi$-SSA web. The property of the
$\psi$-CSSA form is that the renaming into a single variable of all
variables that belong to the same $\psi$-SSA web, and the removal of
the $\psi$ and $\phi$ functions, results in a program with the same
semantics as the original program.

Now, coonsider figure~\ref{fig:psi-interference} to illustrate the
transformations that must be performed to convert a program from a
$\psi$-SSA form into a program in $\psi$-CSSA form.

\begin{figure*}
\begin{center}
\footnotesize
\begin{tabular}{llllllll}
${\tt p?}$ & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt b = ...}$ \\
            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt x = ...}$ \\
            &                 & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt c = b}$   & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt x = b}$ \\
            & ${\tt x = Psi(1?a,p?b)}$ & \ \ \ \ \ \ \ \  &   & ${\tt x = Psi(1?a,p?c)}$  & \ \ \ \ \ \ \ \ &   & \\
\\
\multicolumn{2}{l}{${\tt {\bf (a) Psi-SSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (b) Psi-CSSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (c) non-SSA\ form}}$} \\
\\
            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt x = ...}$ \\
            &                 & \ \ \ \ \ \ \ \  &            & ${\tt d = a}$ & \ \ \ \ \ \ \ \  &            & ${\tt y = x}$ \\
${\tt p?}$ & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt x = ...}$ \\
${\tt q?}$ & ${\tt c = ...}$ & \ \ \ \ \ \ \ \  & ${\tt q?}$ & ${\tt c = ...}$ & \ \ \ \ \ \ \ \  & ${\tt q?}$ & ${\tt y = ...}$ \\
           & ${\tt x = Psi(1?a,p?b)}$ & \ \ \ \ \ \ \ \  &   & ${\tt x = Psi(1?a,p?b)}$  & \ \ \ \ \ \ \ \ &   & \\
           & ${\tt y = Psi(1?a,q?c)}$ & \ \ \ \ \ \ \ \  &   & ${\tt y = Psi(1?d,q?c)}$  & \ \ \ \ \ \ \ \ &   & \\
\\
\multicolumn{2}{l}{${\tt {\bf (d) Psi-SSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (e) Psi-CSSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (f) non-SSA\ form}}$} \\
\end{tabular}
\caption{$\psi$-SSA, $\psi$-CSSA forms and non-SSA form after destruction}
\label{fig:psi-interference}
\end{center}
\end{figure*}

% <<etendre aussi la projection pour la predication partielle ??
% (Propagation des predicats a travers les instructions non gardes par
% un algorithm semblable a la sparse constant propagation) >>

Looking at the first example, the dominance order of the definitions
for the variables {\tt a} and {\tt b} differs from their order from
left to right in the $\psi$ function. Such code may appear after a
code motion algorithm has moved the definitions for {\tt a} and {\tt
b} relatively to each other. We said that the semantics of a
$\psi$ function is dependent on the order of its arguments, and that
the order of the arguments in a $\psi$ function is the order of their
definitions in the dominance tree in the original program. In this
example the renaming of the variables {\tt a}, {\tt b} and {\tt x}
into a single variable will not preserve the semantics of the original
program. The order in which the definitions of the variables {\tt a},
{\tt b} and {\tt x} occur must be corrected. This is done through the
introduction of the variable {\tt c} that is defined as a copy of the
variable {\tt b}, and is inserted after the definition of {\tt
a}. Now, the renaming of the variables {\tt a}, {\tt c} and {\tt x}
into a single variable will result in the correct semantics.

In the second example, the renaming of the variables {\tt a}, {\tt b},
{\tt c}, {\tt x} and {\tt y} into a single variable will not give the
correct semantics. In fact, the value of {\tt a} used in the second
$\psi$ function would be overridden by the definition of {\tt b}
before the definition of the variable {\tt c}. Such code will occur
after copy folding has been applied on a $\psi$-SSA representation. We
see that the value of {\tt a} has to be preserved before the
definition of {\tt b}, resulting in the code given for the $\psi$-CSSA
representation. Now, the variables {\tt a}, {\tt b} and {\tt x} can be
renamed into a single variable, and the variables {\tt d}, {\tt c} and
{\tt y} will be renamed in another variable, resulting in a program in
a non-SSA form with the correct semantics.

We will now present an algorithm that will transform a program from a
$\psi$-SSA form into its $\psi$-CSSA form. This algorithm is made of
three parts.

\begin{itemize}
\item {\bf $\psi$-normalize} This part will put all $\psi$ functions
in what we call a {\em normalized} form.
\item {\bf $\psi$-web} This part will grow $\psi$-SSA webs from $\psi$
  functions, and will introduce repair code where needed.
\item {\bf $\phi$-web} This part will extend the $\psi$-SSA webs with
  $\phi$ functions. This part is very similar to the Sreedhar
  algorithm.
\end{itemize}

We detail now the implementation of each of these three parts.

\subsection{Psi-normalize}

We define the notion of {\em normalized}-$\psi$. When $\psi$
functions are created during the construction of the $\psi$-SSA
representation, they are naturally built in their normalized form. The
normalized form of a $\psi$ function has two characteristics:

\begin{itemize}
\item The predicate associated with each argument in a
normalized-$\psi$ function is equal to the predicate used on the
unique definition of this argument.
\item The order of the arguments in a normalized-$\psi$ function is,
from left to right, equal to the order of their definitions, from top
to bottom, in the control-flow dominance tree.
\end{itemize}

When transformations are applied to the $\psi$-SSA representation,
predicated definitions may be moved relatively to each others.
Operation speculation and copy folding may enlarge the domain of the
predicate used on the definition of a variable. These transformations
may cause some $\psi$ functions to be in a non-normalized form.

%\SubSubSection{PSI-normalize implementation}
\paragraph{PSI-normalize implementation.}
A dominator tree must be available for the control-flow graph to
lookup the dominance relation between basic blocks. The dominance
relation between two operations in a same basic block will be given by
their relative positions in the basic block.

Each $\psi$ function is processed independently. An analysis of the
$\psi$ functions in a top down traversal of the dominator tree
reduces the amount of repair code that is inserted during this pass. We
only detail the algorithm for such a traversal.

For a $\psi$ function, the argument list is processed from left to
right. For each argument $arg_i$, the predicate associated with this
argument in the $\psi$ function and the predicate used on the
definition of this argument are compared. If they are not equal, a new
variable is introduced and is initialized just below the definition
for $arg_i$ with a copy of $arg_i$. This definition is predicated with
the predicate associated with $arg_i$ in the $\psi$ function. Then,
$arg_i$ is replaced by this new variable in the $\psi$
function.

Then, we consider the dominance order of the definition for
$arg_i$, with the definition of the next argument in the $\psi$
argument list, $arg_{i+1}$. When $arg_{i+1}$ is defined on a $\psi$
function, we recursively look for the definition of the first
argument of this $\psi$ function, until a non-$\psi$ function is
found. Now, if the definition we found for $arg_{i+1}$ dominates the
definition for $arg_i$, repair code is needed. A new variable is
created for this repair. This variable is initialized with a copy of
$arg_{i+1}$, guarded by the predicate associated with this argument in
the $\psi$ function. This copy operation is inserted at the lowest
point, either after the definition of $arg_i$ or $arg_{i+1}
$\footnote{When $arg_{i+1}$ is defined by a $\psi$ function, its
definition may appear after the definition for $arg_i$, although the
non-$\psi$ definition for $arg_{i+1}$ appears before the definition
for $arg_i$.}. Then, $arg_{i+1}$ is replaced in the $\psi$ function
by this new variable.

The algorithm continues with the argument $arg_{i+1}$, until all
arguments of the $\psi$ function are processed. When all arguments
are processed, the $\psi$ is in its normalized form. When all $\psi$
functions are processed, the function will contain only
normalized-$\psi$ functions.

The top-down traversal of the dominator tree will ensure that when a
variable in a $\psi$ function is defined by another $\psi$ function,
this $\psi$ function has already been analyzed and put in its
normalized form. Thus the definition of its first variable already
dominates the definitions for the other arguments of the $\psi$
function.

\subsection{Psi-web}

In this pass, we repair the $\psi$ functions when variables cannot be
put into the same $\psi$-SSA web, because their live ranges
interfere. In the same way as Sreedhar gives a definition of the
liveness on the $\phi$ function, we first give a definition for the
liveness on $\psi$ functions. With this definition of liveness, an
interference graph is built.

%\SubSubSection{Liveness and interferences in Psi-SSA}
\paragraph{Liveness and interferences in Psi-SSA.}
We have already seen that in some cases, repair code is needed so that
the arguments and definition of a $\psi$ function can be renamed into
a single name. We first give a definition of the liveness on $\psi$
functions such that these cases can be easily and accurately detected
by observing that live-ranges for variables in a $\psi$ function
overlap.

Consider the code in figure~\ref{fig:psi-select}. The $\psi$ function
has been replaced by explicit {\tt select} operations on each
predicated definition. In this example, there is no relation between
predicates {\tt p} and {\tt q}. Each of these {\tt select} operations
makes an explicit use of the variable immediately to its left in the
argument list of the original $\psi$ function. We can see that a
renaming of the variables {\tt a}, {\tt b}, {\tt c} and {\tt x} into a
single representative name will still compute the same value for the
variable {\tt x}. Note that this transformation can only be performed
on normalized $\psi$ functions, since the definition of an argument
must be dominated by the definition of the argument immediately to its
left in the argument list of the $\psi$ function. Using this
equivalent representation for the $\psi$ function, we now give a
definition of the liveness for the $\psi$ functions.

{\bf Definition} {\em We say that the point of use of an argument in a
normalized $\psi$ function occurs at the point of definition of the
argument immediately to its right in the argument list of the $\psi$
function. For the last argument of the $\psi$ function, the point of
use occurs at the $\psi$ function itself.  }

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
           & ${\tt a = op1}$ & ${\tt a = op1}$ \\
${\tt p?}$ & ${\tt b = op2}$ & ${\tt b = p\ ?\ op2\ :\ a}$ \\
${\tt q?}$ & ${\tt c = op3}$ & ${\tt c = q\ ?\ op3\ :\ b}$ \\
           & ${\tt x = Psi(1?a,p?b,q?c)}$ & ${\tt x = c}$ \\
\\
\multicolumn{2}{l}{\tt {\bf a) Psi-SSA form}} & {\tt {\bf b) select form}}
\end{tabular}
\caption{$\psi$ functions and select operations equivalence}
\label{fig:psi-select}
\end{center}
\end{figure}

Given this definition of liveness on $\psi$ functions, and using the
definition of liveness for $\phi$ functions given by Sreedhar, a
traditional liveness analysis can be run. Then an interference graph
can be built to collect the interferences between variables involved
in $\psi$ or $\phi$ functions.

%\SubSubSection{Repairing interferences on $\psi$ operations}
\paragraph{Repairing interferences on $\psi$ functions.}
We now present an algorithm that creates $\psi$-SSA webs with $\psi$
functions such that there are no interference between two variables in
the same $\psi$-SSA web.

First, the $\psi$-SSA webs are initialized such that each variable in
the $\psi$-SSA representation belongs to its own $\psi$-SSA web. Then,
$\psi$ functions are processed one at a time, in no specific
order. Two arguments of a $\psi$ function interfere if at least one
variable from the web of the first argument interferes with at least
one variable from the web of the second argument. When there is an
interference, the two $\psi$ arguments are marked as needing a
repair. When all pairs of arguments of the $\psi$ function are
analyzed, repair code is inserted. For each argument in the $\psi$
function that needs a repair, a new variable is introduced. This new
variable is initialized with a predicated copy of the argument's
variable. The copy operation is inserted just below the definition of
the argument's variable, predicated with the predicate associated with
the argument in the $\psi$ function.

Once a $\psi$ function has been processed, the interference graph must
be updated, so that other $\psi$ functions are correctly
handled. Interferences for the newly introduced variables must be
added to the interference graph. Conservatively, we can say that each
new variable interferes with all the variables that the original
variable interfered with, except those variables that are now in its
$\psi$-SSA web. Also, conservatively, we can say that the original
variable interferes with the new variable in order to avoid a merge of
a later $\psi$ or $\phi$ function of the two $\psi$-SSA webs these
two variables belong to. The conservative update of the interference
graph may increase the number of copies generated during the
conversion to the $\psi$-CSSA form.
% Some comments on an exact interference graph update ??

Consider the code in figure~\ref{fig:live-interference} to see how
this algorithm works. The definition of liveness on the $\psi$
function will create a live-range for variable {\tt a} that extends
down to the definition of {\tt b}, but not further down. Thus, the
variable {\tt a} does not interfere with the variables {\tt b}, {\tt
  c} or {\tt x}. The live-range for variable {\tt b} extends down to
its use in the definition of variable {\tt d}. This live-range creates
an interference with the variables {\tt c} and {\tt x}. Thus variables
{\tt b}, {\tt c} and {\tt x} cannot be put into the same web. These
variables are renamed respectively into variables {\tt e}, {\tt f} and
{\tt g} and initialized with predicated copies. These copies are
inserted respectively after the definitions for {\tt b}, {\tt c} and
{\tt x}. Variables {\tt a}, {\tt e}, {\tt f} and {\tt g} can now be
put into the same web, and will be renamed later into a unique
representative name.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt p?}$ & ${\tt a = ...}$ & ${\tt p?}$ & ${\tt a = ...}$ \\
${\tt q?}$ & ${\tt b = ...}$ & ${\tt q?}$ & ${\tt b = ...}$ \\
           &                 & ${\tt q?}$ & ${\tt e = b}$ \\
${\tt r?}$ & ${\tt c = ...}$ & ${\tt r?}$ & ${\tt c = ...}$ \\
           &                 & ${\tt r?}$ & ${\tt f = c}$ \\
           & ${\tt x = Psi(p?a,q?b,r?c)}$ & & ${\tt g = Psi(p?a,q?e,r?f)}$ \\
           &                 &            & ${\tt x = g}$ \\
${\tt s?}$ & ${\tt d = b+1}$ & ${\tt s?}$ & ${\tt d = b+1}$ \\
\end{tabular}
\caption{Elimination of $\psi$ live-interference}
\label{fig:live-interference}
\end{center}
\end{figure}

\subsection{Phi-web}

When all $\psi$ functions are processed, the $\psi$-SSA webs built
from $\psi$ functions are extended to include the variables in $\phi$
functions. In this part, the algorithm from Sreedhar is used, with a
few modifications.

The first modification is that the $\psi$-SSA webs must not be
initialized at the beginning of this process. They have already been
initialized at the beginning of the $\psi$-web step, and were extended
during the processing of $\psi$ functions. These webs will be extended
now with $\phi$ functions during this step.

The second modification is that the live-analysis run for this part
must also take into account the special liveness rule on the $\psi$
functions. The reason for this is that for any two variables in the
same $\psi$-SSA web, any interference, either on a $\psi$ or on a
$\phi$ function, will not preserve the correct semantics if the
variables are renamed into a representative name.

All other parts of the SSA destruction algorithm from Sreedhar are
unchanged, and in particular, any of the three algorithms described
for the conversion into a CSSA form can be used.

We have described a complete algorithm to convert a $\psi$-SSA
representation into a $\psi$-CSSA representation. The final step to
convert the code into a non-SSA form is a simple renaming of all the
variables in the same $\psi$-SSA web into a representative name. The
$\psi$ and $\phi$ functions are then removed.

We now present some improvements that can be added so as to reduce
the number of copies inserted by this algorithm.

\subsection{Improvements to the Psi-SSA destruction algorithm}

\paragraph{Non-normalized $\psi$ functions with disjoint predicates.}
When two arguments in a $\psi$ function do not have their definitions
correctly ordered, the $\psi$ function is not normalized. We
presented an algorithm to restore the normalized property by adding a
new predicated definition of a new variable. However, if we know that
the predicate domains of the two arguments are actually disjoint, the
semantics of the $\psi$ function is independent on their relative
order. So, instead of adding repair code, these two arguments can
simply be reordered in the $\psi$ function itself, to restore the
normalized property.

\paragraph{Interference with disjoint predicates.}
When the live-ranges of two variables overlap, an interference is
added for these two variables in the interference graph. If the
definitions for these variables are predicated definitions, their
live-ranges are only valid under a specific predicate domain. These
domains are the domains of the predicates used on the definitions of
the variables. Then, if these domains are disjoint, then although the
live-range overlap, they are on disjoint conditions and thus they do
not create an interference in the interference graph. Removing this
interference from the interference graph will avoid the need to add repair code
when live-ranges on disjoint predicates overlap.

\paragraph{Repair interference on the left argument only.}

When an interference is detected between two arguments in a $\psi$
function, only the argument on the left actually needs a repair. The
reason is that, since the $\psi$ functions are normalized, the
definition of an argument is always dominated by the definition of an
argument on its left. Thus adding a copy for the argument on the right
will not remove the interference. However, the copy must now be put
just before the definition of the next argument in the $\psi$
function, or just before the $\psi$ function if this is the last
argument.

\paragraph{Interference with the result of a $\psi$ function.}

When the live-range for an argument of a $\psi$ function overlaps
with the live-range of the variable defined by the $\psi$ function,
this interference can be ignored. Actually, there are two cases to
consider:

\begin{itemize}
\item If the argument is not the last one in the $\psi$ function, and
its live-range overlaps with the live-range of the definition of the
$\psi$ fuunction, then this live-range also overlaps with the
live-range of the last argument. Thus this interference will already
be detected and repaired.

\item If the argument is the last one of the $\psi$ function, then
the value of the $\psi$ function is the value of this last argument,
and this argument and the definition will be renamed into the same
variable out of the SSA representation. Thus, there is no need to
introduce a copy here.
\end{itemize}

