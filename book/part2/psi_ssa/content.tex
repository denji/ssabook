\chapter{Psi-SSA Form \Author{F. de Ferri\`ere}}
\numberofpages{9}

\chapterauthor{de Ferri\`ere}

\section{Overview}

\textbf{0.5 page}

Explain why SSA renaming cannot be applied on predicated definitions. 

\section{Definition}

\textbf{1 page}

Gives the semantics of the PSI function, doing the parallel with PHI function before if-conversion. Explain the relation between the predicates on the definition and the predicates in the PSI. Explain how a PSI function is executed.

\section{Construction}

\textbf{0.5 page}

Explain how PSI instructions are built, either during the SSA construction on predicated instructions, or during if-conversion under SSA by converting PHI functions into PSI functions.

\section{SSA algorithms}

\textbf{1 page}

Explain how standard SSA algorithm can be adapted to the Psi-SSA form: Predicated definitions are now seen as non-predicated ones, and a semantics, similar to the similar of PHI functions, must be defined for PSI functions.

\section{Psi-SSA algorithms}

\textbf{3 page}

Special transformations can be applied on Psi-SSA, which allows to optimize predicated code. Explain on an example what are the uses of inlining, reduction, projection and predicate promotion.

\section{Out of Psi-SSA}

\textbf{3 page}

Explain what must be done to go out of Psi-SSA. First, Psi-normalization must be performed, then live-analysis can be run and an interference graph with exact interfences on Psi operations can be built. Explain how to repair the interferences and how to integrate this algorithm into a standard SSA algorithm.

