\chapter{Psi-SSA Form \Author{F. de Ferri\`ere}}
\inputprogress

\section{Overview}

% Explain why SSA renaming cannot be applied on predicated definitions. 

% The $\psi$-SSA representation was developed to extend the SSA
% representation with support for predicated operations.

In the SSA representation, each definition of a variable is given a
unique name, and new pseudo definitions are introduced on $\phi$
functions to merge values coming from different control-flow paths. An
example is given figure~\ref{fig:op_ssa}. Each definition is an
unconditional definition, and the value of a variable is the value of
the expression on the unique assignment to this variable. This
essential property of the SSA representation does not any longer hold
when definitions may be conditionally executed. When the definition
for a variable is a predicated operation, the value of the variable
will or will not be modified depending on the value of a guard
register. As a result, the value of the variable after the predicated
operation is either the value of the expression on the assignment if
the predicate is true, or the value the variable had before this
operation if the predicate is false. We need a way to express these
conditional definitions whilst keeping the static single assignment
property.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt a = op1}$ & & & ${\tt a_1 = op1}$ \\
${\tt if (p)}$        & & & ${\tt if (p)}$ \\
${\tt\ \ \ \ \ a = op2;}$ & & & ${\tt \ \ \ \ \ a_2 = op2;}$ \\
& & & ${\tt a_3 = Phi(a_1, a_2)}$ \\
${\tt \ = a}$ & & & ${\tt \ = a_3}$ \\
\end{tabular}
\caption{SSA representation}
\label{fig:op_ssa}
\end{center}
\end{figure}

\section{Definition and Construction}

\textbf{1 page}

% Gives the semantics of the PSI function, doing the parallel with PHI
% function before if-conversion. Explain the relation between the
% predicates on the definition and the predicates in the PSI. Explain
% how a PSI function is executed.

Predicated operations are used to remove control-flow instructions.
These instructions may be present in the intermediate representation
as a result of inlining of assembly code. The compiler may also
generate these operations by performing an if-conversion
optimization~\ref{chap:if-conversion} that removes control-flow
operations and replaces conditionally executed code by predicated
instructions.

This is illustrated in figure~\ref{fig:op_pred0}. We use the notation
{\tt p? a = op} to indicate that the operation {\tt a = op} is
executed only if predicate {\tt p} is true, and is ignored
otherwise. We will also use the notation ${\tt \overline{p}}$ to refer
to the complement of predicate {\tt p}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt a_1 = op1}$ & & & ${\tt a_1 = op1}$ \\
${\tt if (p)}$        & & & \\
${\tt\ \ \ \ \ a_2 = op2;}$ & \ \ \ \ \  & ${\tt p?}$ & ${\tt a_2 = op2;}$ \\
${\tt a_3 = Phi(a_1, a_2)}$ & & & \\
${\tt \ = a_3}$ & & & ${\tt \ = a??}$ \\
\end{tabular}
\caption{SSA on predicated code}
\label{fig:op_pred0}
\end{center}
\end{figure}

On this example, the use of {\tt a} on the last instruction refers to
the variable ${\tt a_1}$ if {\tt p} is false, or to the variable ${\tt
  a_2}$ if {\tt p} is true. These multiple reaching definitions on the
use of {\tt a} cannot be represented by the standard SSA
representation.

One possible representation would be to use the Gated SSA form,
presented in Chapter~\ref{chap:vsdg}. In such a representation, the
$\phi$ function would be augmented with the predicate {\tt p} to tell
which value between ${\tt a_1}$ and ${\tt a_2}$ is to be
considered. However, Gated SSA is a completely different intermediate
representation where the control-flow is no longer represented. This
representation is more suited for program interpretation or hardware
synthesis, SSA algorithm for optimizations and code generations cannot
be directly applied.

Another possible representation would be to add a reference to ${\tt
  a_1}$ on the definition of ${\tt a_2}$. Now, ${\tt a_2}$ holds the
value of ${\tt a_1}$ if {\tt p} is false, or the value of ${\tt op2}$
if {\tt p} is true. The use of {\tt a} on the last instruction now
refers to the variable ${\tt a_2}$, which holds the correct value. The
drawback of this representation is that it adds dependencies between
operations, which will prevent code reordering for scheduling. It will
also create useless dependencies when there are definitions on
disjoints predicates that will be difficult to ignore or remove.

Our solution is presented in figure~\ref{fig:op_pred}. The $\phi$
function is replaced by a $\psi$ function, with information on the
predicate associated with each argument. This representation is
adapted to code optimization and code generation on a low-level
intermediate representation.

A $\psi$ function is written ${\tt a_0 = Psi(p_1?a_1, ..., p_i?a_i,
  ..., p_n?a_n)}$. A $\psi$ function defines one variable, ${\tt
  a_0}$, and takes a variable number of arguments ${\tt a_i}$. Each
argument is associated with a predicate ${\tt p_i}$. In the notation,
the predicate ${\tt p_i}$ associated with an argument ${\tt a_i}$ will
be omitted if ${\tt p_i \equiv true}$.

A $\psi$ function has the following properties:

\begin{itemize}

\item{\emph{It is an operation}} A $\psi$ function is a regular operation. It
  can occur at any location in a basic block where a regular operation
  is valid. Each argument ${\tt a_i}$, and each predicate ${\tt p_i}$,
  must be dominated by its definition.

\item{\emph{It is predicated}} A $\psi$ function is a predicated
  operation, under the predicate ${\tt \bigcup_{k=1}^n p_k}$,
  although this predicate is not explicit in the representation.

\item{\emph{It has an ordered list of arguments}} The order of the
  arguments in a $\psi$ function is significant. A $\psi$ function is
  evaluated from left to right. The value of a $\psi$ function is the
  value of the right most argument whose predicate is true.

\item{\emph{Rule on predicates}} The predicate ${\tt p_i}$ associated
  with the argument ${\tt a_i}$ in a $\psi$ function must be included
  in or equal to the predicate on the definition of the variable ${\tt
    a_i}$.

\begin{tabular}{ll}
\multicolumn{2}{l}{\it for the instructions}\\
${\tt p?}$ & ${\tt a_i = ...}$\\
& ${\tt a_0 = Psi(..., p_i?a_i, ...)}$\\
\multicolumn{2}{l}{\it then}\\
& ${\tt p_i} \subseteq {\tt p}$\\
\end{tabular}

\end{itemize}

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt a_1 = op1}$ & & & ${\tt a_1 = op1}$ \\
${\tt if (p)}$        & & & \\
${\tt\ \ \ \ \ a_2 = op2;}$ & \ \ \ \ \  & ${\tt p?}$ & ${\tt a_2 = op2;}$ \\
${\tt a_3 = Phi(a_1, a_2)}$ & & & ${\tt a_3 = Psi(a_1, p?a_2)}$ \\
${\tt \ = a_3}$ & & & ${\tt \ = a_3}$ \\
\end{tabular}
\caption{$\psi$-SSA representation}
\label{fig:op_pred}
\end{center}
\end{figure}

A $\psi$ function can represent cases where variables are defined on
predicates that are computed from independent conditions. This is
illustrated in figure~\ref{fig:non_disjoint_pred}, where the
predicates {\tt p} and {\tt q} are independent. During the SSA
construction a unique variable {\tt a} was renamed into the variables
${\tt a_1}$, ${\tt a_2}$ and ${\tt a_3}$ and the variables ${\tt x_1}$
and ${\tt x_2}$ were introduced to merge values coming from different
control-flow paths. In the non-predicated code, there is a
control-dependency between ${\tt x_1}$ and ${\tt a_3}$, which means
the definition of ${\tt a_3}$ must be executed after the value for
${\tt x_1}$ has been computed. In the predicated form of this example,
there is no longer any control dependencies between the definitions of
${\tt a_1}$, ${\tt a_2}$ and ${\tt a_3}$. A compiler transformation
can now freely move these definitions independently of each other,
which may allow more optimizations to be performed on this
code. However, the semantics of the original code requires that the
definition of ${\tt a_3}$ occurs after the definitions of ${\tt a_1}$
and ${\tt a_2}$. The order of the arguments in a $\psi$ function gives
information on the original order of the definitions. We take the
convention that the order of the arguments in a $\psi$ function is,
from left to right, equal to the original order of their definitions,
from top to bottom, in the control-flow dominance tree of the program
in a non-SSA representation. This information is needed to maintain
the correct semantics of the code during transformations of the
$\psi$-SSA representation and to revert the code back to a non
$\psi$-SSA representation.

%An important property of the SSA, and $\psi$-SSA, representation is
%that every use of a variable is dominated by the unique definition for
%this variable.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt if (p)}$        & & & \\
${\tt\ \ \ \ \ a_1 = 1;}$ & \ \ \ \ \  & ${\tt p?}$ & ${\tt a_1 = 1;}$ \\
${\tt else}$          & & & \\
${\tt\ \ \ \ \     a_2 = -1;}$ & \ \ \ \ \  & ${\tt \overline{p}?}$ & ${\tt a_2 = -1;}$ \\
${\tt x_1 = Phi(a_1, a_2)}$ & & & ${\tt x_1 = Psi(p?a_1, \overline{p}?a_2)}$ \\
${\tt if (q)}$        & & & \\
${\tt\ \ \ \ \ a_3 = 0;}$ & \ \ \ \ \  & ${\tt q?}$ & ${\tt a_3 = 0;}$ \\
${\tt x_2 = Phi(x_1, a_3)}$ & & & ${\tt x_2 = Psi(p?a_1, \overline{p}?a_2, q?a_3)}$ \\
\end{tabular}
\caption{$\psi$-SSA with non-disjoint predicates}
\label{fig:non_disjoint_pred}
\end{center}
\end{figure}


% Explain how PSI instructions are built, either during the SSA
% construction on predicated instructions, or during if-conversion
% under SSA by converting PHI functions into PSI functions.

The construction of the $\psi$-SSA representation is a small
modification on the standard algorithm to built an SSA representation.

The insertion of $\psi$ functions is performed in the SSA renaming
phase of a classical SSA construction algorithm, described
in~\ref{chap:classical_construction}.

During the SSA renaming phase, basic blocks are processed in their
dominance order, and operations in each basic block are scanned from
top to bottom. On an operation, for each predicated definition of a
variable, a new $\psi$ function will be inserted just after the
operation. For the definition of a variable {\tt x} under predicate
{\tt p}, the $\psi$ function will take the form ${\tt x = Psi(p?x_1,
  p?x)}$, where ${\tt x_1}$ is the current renaming of {\tt x} before
the definition, and {\tt p} is the predicate used on the definition of
${\tt x_1}$. Once this instruction is inserted, the normal renaming of
the operation proceeds, renaming {\tt x} into a new name ${\tt
  x_2}$. When the renaming of the operation is completed, the
algorithm continues on the next instruction, which will be a $\psi$
function if there was a predicated definition. The first argument of
the $\psi$ function is already renamed and thus is not modified. The
second argument is renamed into the current renaming for {\tt x}
which is ${\tt x_2}$. On the definition of the $\psi$ function, the
variable {\tt x} is given a new name, ${\tt x_3}$, which becomes the
renaming for further references to the {\tt x} variable. This
insertion and renaming of a $\psi$ function is shown on
figure~\ref{fig:psi_ssa_construct}

$\psi$ functions can also be introduced in an SSA representation by
applying an if-conversion transformation, such as the one that is
described in~\ref{chap:if-conversion}. Local transformations on
control-flow patterns can also require to replace $\phi$ functions by
$\psi$ functions.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllllllllll}
${\tt p?}$ & ${\tt x = op}$ & \ \ \ \  & ${\tt p?}$ & ${\tt x = op}$           & \ \ \ \  & ${\tt p?}$ & ${\tt x_2 = op}$           & \ \ \ \  & ${\tt p?}$ & ${\tt x_2 = op}$ \\
           &                &          &            & ${\tt x = psi(x_1, p?x)}$ &           &           & ${\tt x = psi(x_1, p?x_2)}$ &          &           & ${\tt x_3 = psi(x_1, p?x_2)}$ \\
\end{tabular}
\caption{Construction and renaming of $\psi$-SSA}
\label{fig:psi_ssa_construct}
\end{center}
\end{figure}


\section{SSA algorithms}

\textbf{1 page}

% Explain how standard SSA algorithm can be adapted to the Psi-SSA
% form: Predicated definitions are now seen as non-predicated ones,
% and a semantics, similar to the similar of PHI functions, must be
% defined for PSI functions.

With this definition of the $\psi$-SSA representation, conditional
definitions on predicated code are now replaced by unconditional
definitions on $\psi$ functions. Usual algorithms that perform
optimizations or transformations on the SSA representation can now be
easily adapted to the $\psi$-SSA representation, without compromising
the efficiency of the transformations performed. Actually, within the
$\psi$-SSA representation, predicated definitions behave exactly the
same as non predicated ones for optimizations on the SSA
representation. Only the $\psi$ functions have to be treated in a
specific way. As an example, the constant propagation algorithm
described in~\cite{WZ91} can be easily adapted to the $\psi$-SSA
representation. In this algorithm, the only modification is that
$\psi$ functions have to be handled with the same rules as the $\phi$
functions. Other algorithms such as dead code
elimination~\cite{morgan98}, global value numbering~\cite{Cli95},
partial redundancy elimination~\cite{CCK+97}, and induction variable
analysis~\cite{Wolfe92} are examples of algorithm that can easily be
adapted to this representation.

\section{Psi-SSA algorithms}

\textbf{3 page}

% Special transformations can be applied on Psi-SSA, which allows to
% optimize predicated code. Explain on an example what are the uses of
% inlining, reduction, projection and predicate promotion.

In addition to standard algorithms that can be applied to $\psi$
functions and predicated code, a number of specific transformations
can be performed on the $\psi$ functions : $\psi$-inlining,
$\psi$-reduction, $\psi$-projection, $\psi$-permutation and
$\psi$-promotion. For a $psi$ function ${\tt a_0 = Psi(p_1?a_1, ...,
  p_i?a_i, ..., p_n?a_n)}$, these transformations are defined as
follows:

\begin{itemize}

\item{\emph{$\psi$-inlining}} will recursively replace in a $\psi$
  function an argument $a_i$ that is defined on another $\psi$
  function by the arguments of this other $\psi$ function. The
  predicated $p_i$ associated with argument $a_i$ will be distributed
  with an $and$ operation over the predicates associated with the
  inlined arguments. This is shown in figure~\ref{fig:psi_inlining}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
             & ${\tt a_1 = op_1}$             & \ \ \ \  &             & ${\tt a_1 = op_1}$ \\
${\tt p_2?}$ & ${\tt a_2 = op_2}$             & \ \ \ \  & ${\tt p_2?}$ & ${\tt a_2 = op_2}$ \\
             & ${\tt x_1 = Psi(a_1, p_2?a_2)}$ & \ \ \ \  &             & ${\tt x_1 = Psi(a_1, p_2?a_2) // dead}$ \\
${\tt p_3?}$ & ${\tt a_3 = op_3}$              & \ \ \ \  & ${\tt p_3?}$ & ${\tt a_3 = op_3}$ \\
             & ${\tt x_2 = Psi(p_1?x_1, p_3?a_3)}$ & \ \ \ \  &           &${\tt x_2 = Psi(p_1?a_1, p_1&p_2?a_2, p_3?a_3)}$ \
\end{tabular}
\caption{$\psi$-inlining}
\label{fig:psi_inlining}
\end{center}
\end{figure}


\item{\emph{$\psi$-reduction}} will remove from a $\psi$ function an
  argument $a_i$ whose value will always be overridden by arguments on
  its right in the argument list. An argument ${\tt a_i}$ associated
  with predicate ${\tt p_i}$ can be removed if ${\tt p_i \subseteq
    \bigcup_{k=i+1}^n p_k}$. This is shown in
  figure~\ref{fig:psi_reduction}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
             & ${\tt a_1 = op_1}$             & \ \ \ \  &             & ${\tt a_1 = op_1}$ \\
${\tt p_2?}$ & ${\tt a_2 = op_2}$             & \ \ \ \  & ${\tt p_2?}$ & ${\tt a_2 = op_2}$ \\
${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$              & \ \ \ \  & ${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$ \\
             & ${\tt x_2 = Psi(a_1, p_2?a_2, \overline{p_2}?a_3)}$ & \ \ \ \  &              &${\tt x_2 = Psi(p_2?a_2, \overline{p_2}?a_3)}$ \\
\end{tabular}
\caption{$\psi$-reduction}
\label{fig:psi_reduction}
\end{center}
\end{figure}

\item{\emph{$\psi$-projection}} will create from a $\psi$ function a
  new $\psi$ function for use in an operation predicated under a given
  predicate. In this new $\psi$ function, arguments whose associated
  predicate has a domain that is disjoint with the domain of the
  predicate on which the projection is performed actually contribute
  no value to the $\psi$ function and thus are removed. This is shown
  in figure~\ref{fig:psi_projection}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
${\tt p_2?}$ & ${\tt a_2 = op_2}$             & \ \ \ \  & ${\tt p_2?}$ & ${\tt a_2 = op_2}$ \\
${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$              & \ \ \ \  & ${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$ \\
             & ${\tt x_2 = Psi(p_2?a_2, \overline{p_2}?a_3)}$ & \ \ \ \  &              &${\tt x_2 = Psi(p_2?a_2, \overline{p_2}?a_3)}$ \\
             &                               & \ \ \ \  &              & ${\tt x_3 = Psi(p_2?a_2)}$ \\
${\tt p_2?}$ & ${\tt y_1 = x_2}$              & \ \ \ \  & ${\tt p_2?}$ & ${\tt y_1 = x_3}$ \\
\end{tabular}
\caption{$\psi$-projection}
\label{fig:psi_projection}
\end{center}
\end{figure}

\item{\emph{$\psi$-permutation}} will change the order of the
  arguments in a $\psi$ function. In a $\psi$ function the order of
  the arguments is significant, and we will see that for the
  destruction of the $\psi$-SSA representation this order from left to
  right must be identical to the dominance order from top to bottom of
  the definitions of these arguments. After code motion or copy
  propagation, the dominance order of the definitions of $\psi$
  arguments may be changed. Two arguments in a $\psi$ function can be
  permuted if the intersection of their associated predicate in the
  $\psi$ argument list is empty. An example of such a permutation is
  shown on figure~\ref{fig:psi_permutation}.

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{lllll}
${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$              & \ \ \ \  & ${\tt \overline{p_2}?}$ & ${\tt a_3 = op_3}$ \\
${\tt p_2?}$ & ${\tt a_2 = op_2}$             & \ \ \ \  & ${\tt p_2?}$ & ${\tt a_2 = op_2}$ \\
             & ${\tt x_2 = Psi(p_2?a_2, \overline{p_2}?a_3)}$ & \ \ \ \  &              &${\tt x_2 = Psi(\overline{p_2}?a_3, p_2?a_2)}$ \\
\end{tabular}
\caption{$\psi$-permutation}
\label{fig:psi_permutation}
\end{center}
\end{figure}

%% In this case, as a result of speculation performed
%% during an if-conversion algorithm, the guard used on the definition of
%% a variable may be larger than the guard associated with this variable
%% in a $\psi$ operation. Speculation may be performed because some
%% operations cannot be predicated. Speculation may also be performed as
%% an optimization to reduce the number of guards on predicated code and
%% to reduce the number of operations to compute these guards.

\item{\emph{$\psi$-promotion}} will change the predicates used in a
  $\psi$ function. The $\psi$-SSA representation can be used on a
  partially predicated architecture, where only a subset of the
  instructions supports a predicate operand.
  Figure~\ref{fig:psi_partial} shows an example where some code with
  control-flow edges was transformed into a linear sequence of
  instructions.

Taking the example of an architecture where the {\tt ADD} operation
cannot be predicated, the {\tt ADD} operation has been speculated
under the {\tt true} predicate. However, the information represented
in the $\phi$ function by the control-flow edges is now present in the
$\psi$ function by means of predicates.

On an architecture where the {\tt ADD} operation can be predicated, it
may also be profitable to perform speculation in order to reduce the
number of predicates on predicated code and to reduce the number of
operations to compute these predicates. Using the representation in
figure~\ref{fig:psi_partial} (b), there can be one predicate associated
with the definition of a variable, and there will be one predicate
associated with the use of the variable in a $\psi$ function.

Once speculation has been performed on the definition of a variable
used in a $\psi$ function, the predicate associated with this
argument can be promoted, without changing the semantics of the $\psi$
function. By predicate promotion, we mean that a predicate can be
replaced by a predicate with a larger predicate domain. This promotion
must obey the following condition so that the semantics of the $\psi$
function after the transformation is valid and unchanged :

\begin{tabular}{ll}
\multicolumn{2}{l}{\it for an instruction} \\
\ \ \ \ & {$ {\tt y = Psi(p_1?x_1, ..., p_i?x_i, ..., p_n?x_n)}$} \\
\multicolumn{2}{l}{\it transformed to} \\
\ \ \ \ & {$ {\tt y = Psi(p_1?x_1, ..., p_i'?x_i, ..., p_n?x_n)}$} \\
\multicolumn{2}{l}{\it then} \\
\ \ \ \ & {${\tt p_i' \subseteq \bigcup_{k=i}^n p_k}$} \\
\end{tabular}

This promotion must also satisfies the properties of $\psi$
functions, and in particular, that the predicate associated with a
variable in a $\psi$ function must be included in or equal to the
predicate on the definition of that variable. This promotion will not
change the predicate of a $\psi$ function, defined as ${\tt
  \bigcup_{k=1}^n p_k}$.

\begin{figure*}
\begin{center}
\footnotesize
\begin{tabular}{llll}
${\tt if (p)}$                & & & \\
${\tt\ \ \ \ \ a_1 = ADD\ i_1,1;}$ & \ \ \ \ \ \ \ \  & \ \ \ \ \ \ \ \  & ${\tt a_1 = ADD\ i_1,1;}$ \\
${\tt else}$                  & \ \ \ \ \ \ \ \  & \ \ \ \ \ \ \ \  & \\
${\tt\ \ \ \ \ a_2 = ADD\ i_1,2;}$ & \ \ \ \ \ \ \ \  & \ \ \ \ \ \ \ \  & ${\tt a_2 = ADD\ i_1,2;}$ \\
${\tt x = Phi(a_1, a_2)}$         & \ \ \ \ \ \ \ \  & \ \ \ \ \ \ \ \  & ${\tt x = Psi(p?a_1, \overline{p}?a_2)}$ \\
\\
\multicolumn{2}{l}{${\tt{\bf (a)\ before\ if-conversion}}$} & \multicolumn{2}{l}{${\tt{\bf (b)\ Psi\ operation}}$} \\
\end{tabular}
\caption{$\psi$-SSA for partial predication}
\label{fig:psi_partial}
\end{center}
\end{figure*}

% The two domains for these two predicates do not need to be equal,
% only the domain of the predicate on the definition has to contain
% the domain of the predicate on the $\psi$ argument.

% True only if the predicate domain of the $\psi$ operation is 1.

%% \begin{itemize}

%% \item {\bf Condition 1} For an argument in a $\psi$ operation, the
%% domain of the predicate used on the definition of this argument must
%% contain the domain of the new predicate associated with this argument.

%% \begin{tabular}{ll}
%% \multicolumn{2}{l}{\it for the instructions}\\
%% ${\tt p?}$ & ${\tt x = ...}$\\
%% & ${\tt y = Psi(..., q? x, ...)}$\\
%% \multicolumn{2}{l}{\it then}\\
%% & {${\tt q} \subseteq {\tt p}$}\\
%% \end{tabular}

%% \item {\bf Condition 2} For an argument in a $\psi$ operation, the
%% domain of the new predicate associated with it can be extended up to
%% include the domains of the predicates associated with arguments in the
%% $\psi$ operation that were defined after the definition for this
%% argument in the original program.

%% \begin{tabular}{ll}
%% \multicolumn{2}{l}{\it for an instruction} \\
%% \ \ \ \ & {$ {\tt y = Psi(p_1?x_1, p_2?x_2, ..., p_i?x_i, ..., p_n?x_n)}$} \\
%% \multicolumn{2}{l}{\it transformed to} \\
%% \ \ \ \ & {$ {\tt y = Psi(p_1?x_1, p_2?x_2, ..., p_i'?x_i, ..., p_n?x_n)}$} \\
%% \multicolumn{2}{l}{\it then} \\
%% \ \ \ \ & {${\tt p_i' \subseteq \bigcup_{k=i}^n p_k}$} \\
%% \end{tabular}

%% \end{itemize}

Usually, the first argument of a $\psi$ function can be promoted
under the {\tt true} predicate. Also, when disjoint conditions are
computed, one of them can be promoted to include the other conditions,
usually reducing the number of predicates. A side effect of this
transformation is that it may increase the number of copy instructions
to be generated during the $\psi$-SSA destruction phase, because of
more live-range interference between arguments in a $\psi$ function,
as will be explained in next section~\ref{sec:Psi_ssa_destruction}.

\end{itemize}

\section{Psi-SSA destruction}
\label{sec:Psi_ssa_destruction}

\textbf{3 page}

% Explain what must be done to go out of Psi-SSA. First,
% Psi-normalization must be performed, then live-analysis can be run
% and an interference graph with exact interferences on Psi operations
% can be built. Explain how to repair the interferences and how to
% integrate this algorithm into a standard SSA algorithm.

The SSA destruction phase reverts an SSA representation into a non-SSA
representation. This phase must be adapted to the $\psi$-SSA
representation. The algorithm we present here is derived from the SSA
destruction algorithm from Sreedhar et
al.~\ref{chap:alternative_destruction}. This algorithm uses $\psi$-SSA
webs to create a conventional $\psi$-SSA representation. We extend the
notion of SSA webs initially defined for $\phi$ to $\phi$ and $\psi$
operations to derive the notion of conventional $\psi$-SSA ({\em
  $\psi$-CSSA}) form. A $\psi$-SSA web is a non empty, minimal, set of
variables such that if two variables are referenced on the same $\phi$
or $\psi$ function then they are in the same $\psi$-SSA web. The
property of the $\psi$-CSSA form is that the renaming into a single
variable of all variables that belong to the same $\psi$-SSA web, and
the removal of the $\psi$ and $\phi$ functions, results in a program
with the same semantics as the original program.

% We define the conventional $\psi$-SSA ({\em $\psi$-CSSA}) form in a
% similar way to the Sreedhar definition of the conventional SSA ({\em
% CSSA}) form. The $\psi$-SSA web definition is an extension of the
% SSA web to include $\psi$ functions.

Now, consider figure~\ref{fig:psi_interference} to illustrate the
transformations that must be performed to convert a program from a
$\psi$-SSA form into a program in $\psi$-CSSA form.

\begin{figure*}
\begin{center}
\footnotesize
\begin{tabular}{llllllll}
${\tt p?}$  & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt b = ...}$ \\
            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt x = ...}$ \\
            &                 & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt c = b}$   & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt x = b}$ \\
            & ${\tt x = Psi(a,p?b)}$ & \ \ \ \ \ \ \ \  &     & ${\tt x = Psi(a,p?c)}$  & \ \ \ \ \ \ \ \ &     & \\
\\
\multicolumn{2}{l}{${\tt {\bf (a) Psi-SSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (b) Psi-CSSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (c) non-SSA\ form}}$} \\
\\
            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt x = ...}$ \\
            & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt b = ...}$ \\
            &                 & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt c = b}$   & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt x = b}$ \\
            & ${\tt x = Psi(a,p?b)}$ & \ \ \ \ \ \ \ \  &     & ${\tt x = Psi(a,p?c)}$  & \ \ \ \ \ \ \ \ &     & \\
\\
\multicolumn{2}{l}{${\tt {\bf (d) Psi-SSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (e) Psi-CSSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (f) non-SSA\ form}}$} \\
\\
            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt a = ...}$ & \ \ \ \ \ \ \ \  &            & ${\tt x = ...}$ \\
            &                 & \ \ \ \ \ \ \ \  &            & ${\tt d = a}$ & \ \ \ \ \ \ \ \  &            & ${\tt y = x}$ \\
${\tt p?}$  & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt b = ...}$ & \ \ \ \ \ \ \ \  & ${\tt p?}$ & ${\tt x = ...}$ \\
${\tt q?}$  & ${\tt c = ...}$ & \ \ \ \ \ \ \ \  & ${\tt q?}$ & ${\tt c = ...}$ & \ \ \ \ \ \ \ \  & ${\tt q?}$ & ${\tt y = ...}$ \\
            & ${\tt x = Psi(a,p?b)}$ & \ \ \ \ \ \ \ \  &     & ${\tt x = Psi(a,p?b)}$  & \ \ \ \ \ \ \ \ &     & \\
            & ${\tt y = Psi(a,q?c)}$ & \ \ \ \ \ \ \ \  &     & ${\tt y = Psi(d,q?c)}$  & \ \ \ \ \ \ \ \ &     & \\
\\
\multicolumn{2}{l}{${\tt {\bf (g) Psi-SSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (h) Psi-CSSA\ form}}$} & \ \ \ \ \ \ \ \  &\multicolumn{2}{l}{${\tt {\bf (i) non-SSA\ form}}$} \\
\end{tabular}
\caption{$\psi$-SSA, $\psi$-CSSA forms and non-SSA form after destruction}
\label{fig:psi_interference}
\end{center}
\end{figure*}

%% <<etendre aussi la projection pour la predication partielle ??
%% (Propagation des predicats a travers les instructions non gardes
%% par un algorithm semblable a la sparse constant propagation) >>

Looking at the first example, the dominance order of the definitions
for the variables {\tt a} and {\tt b} differs from their order from
left to right in the $\psi$ function. Such code may appear after a
code motion algorithm has moved the definitions for {\tt a} and {\tt
b} relatively to each other.

%% We said that the semantics of a $\psi$ function is dependent on the
%% order of its arguments, and that the order of the arguments in a
%% $\psi$ function is the order of their definitions in the dominance
%% tree in the original program.

In figure~\ref{fig:psi_interference}(a) the renaming of the variables
{\tt a}, {\tt b} and {\tt x} into a single variable will not restore
the semantics of the original program. The order in which the
definitions of the variables {\tt a}, {\tt b} and {\tt x} occur must
be corrected. This is done through the introduction of the variable
{\tt c} that is defined as a predicated copy of the variable {\tt b},
and is inserted after the definition of {\tt a}. Now, the renaming of
the variables {\tt a}, {\tt c} and {\tt x} into a single variable will
result in the correct behavior.

In figure~\ref{fig:psi_interference}(d) the definition of the variable
{\tt b} has been speculated. However, the semantics of the $\psi$
operation is that the variable {\tt x} will only be assigned the value
of {\tt b} when {\tt p} is true. A new variable {\tt c} must be
introduced, after the definition of {\tt b} and {\tt p}. This variable
is defined as a predicated copy of the variable {\tt b}. In the
${\psi}$ function, variable {\tt b} is replaced by variable {\tt c},
and the renaming of variables {\tt a}, {\tt c} and {\tt x} into a
single variable will now restore the correct behavior.

In figure~\ref{fig:psi_interference}(g), the renaming of the variables
{\tt a}, {\tt b}, {\tt c}, {\tt x} and {\tt y} into a single variable
will not give the correct semantics. In fact, the value of {\tt a}
used in the second $\psi$ function would be overridden by the
definition of {\tt b} before the definition of the variable {\tt
  c}. Such code will occur after copy folding has been applied on a
$\psi$-SSA representation. We see that the value of {\tt a} has to be
preserved before the definition of {\tt b}, resulting in the code
given for the $\psi$-CSSA representation. Now, the variables {\tt a},
{\tt b} and {\tt x} can be renamed into a single variable, and the
variables {\tt d}, {\tt c} and {\tt y} will be renamed in another
variable, resulting in a program in a non-SSA form with the correct
behavior.

We will now present an algorithm that will transform a program from a
$\psi$-SSA form into its $\psi$-CSSA form. This algorithm is made of
three parts.

\begin{itemize}
\item {\bf $\psi$-normalize} This part will put all $\psi$ functions
in what we call a {\em normalized} form.
\item {\bf $\psi$-web} This part will grow $\psi$-SSA webs from $\psi$
  functions, and will introduce repair code where needed.
\item {\bf $\phi$-web} This part will extend the $\psi$-SSA webs with
  $\phi$ functions. This part is very similar to the SSA destruction
  algorithm presented in chapter~\ref{chap:alternative_destruction}.
\end{itemize}

We detail now the implementation of each of these three parts.

\subsection{Psi-normalize}

We define the notion of {\em normalized}-$\psi$. When $\psi$ functions
are created during the construction of the $\psi$-SSA representation,
they are naturally built in their normalized form. Later,
transformations are applied to the $\psi$-SSA representation.
Predicated definitions may be moved relatively to each others, and
operation speculation and copy folding may enlarge the domain of the
predicate used on the definition of a variable. These transformations
may cause some $\psi$ functions to be in a non-normalized form.

The normalized form of a $\psi$ function has two characteristics:

\begin{itemize}
\item The order of the arguments in a normalized-$\psi$ function is,
from left to right, equal to the order of their definitions, from top
to bottom, in the control-flow dominance tree.
\item The predicate associated with each argument in a
normalized-$\psi$ function is equal to the predicate used on the
unique definition of this argument.
\end{itemize}

These two characteristics correspond respectively to the two cases
presented in figure~\ref{fig:psi_interference}(a) and
figure~\ref{fig:psi_interference}(d).

When some arguments of a $\psi$ function are also defined by $\psi$
functions, the {\em normalized}-$\psi$ characteristics must hold on a
virtual $\psi$ function where $\psi$-inlining has been performed on
these arguments.

%\SubSubSection{PSI-normalize implementation}
\paragraph{PSI-normalize implementation.}

Each $\psi$ function is processed independently. An analysis of the
$\psi$ functions in a top down traversal of the dominator tree
reduces the amount of repair code that is inserted during this pass. We
only detail the algorithm for such a traversal.

For a $\psi$ function ${\tt a_0 = Psi(p_1?a_1, ..., p_i?a_i, ...,
  p_n?a_n)}$, the argument list is processed from left to right. For
each argument $a_i$, the predicate $p_i$ associated with this argument
in the $\psi$ function and the predicate used on the definition of
this argument are compared. If they are not equal, a new variable
$a'_i$ is introduced and is initialized at the highest point in the
dominator tree after the definition of $a_i$ and $p_i$. $a'_i$ is
defined by the operation ${\tt p_i? a'_i = a_i}$. Then, $a_i$ is
replaced by $a'_i$ in the $\psi$ function.

Then, we consider the dominance order of the definition for $a_i$,
with the definition for $a_{i+1}$. When $a_{i+1}$ is defined on a
$\psi$ function, we recursively look for the definition of the first
argument of this $\psi$ function, until a definition on a non-$\psi$
function is found. Now, if the definition we found for $a_{i+1}$
dominates the definition for $a_i$, some correction is needed.

If the predicates $p_i$ and $p_{i+1}$ are disjoint, a
$\psi$-permutation can be applied between $a_i$ and $a_{i+1}$, so as
to reflect into the $\psi$ function the actual dominance order of the
definitions of $a_i$ and $a_{i+1}$.

If $\psi$-permutation cannot be applied, a new variable $a'_{i+1}$ is
created for repair. $a'_{i+1}$ is defined by the operation ${\tt
  p_{i+1}? a'_{i+1} = a_{i+1}}$. This copy operation is inserted at
the highest point that is dominated by the definitions of $a_i$ and
$a_{i+1}$.

\footnote{When $a_{i+1}$ is defined by a $\psi$ function, its
  definition may appear after the definition for $a_i$, although the
  non-$\psi$ definition for $a_{i+1}$ appears before the definition
  for $a_i$.}. Then, $a_{i+1}$ is replaced in the $\psi$ function by
this new variable.

The algorithm continues with the argument $a_{i+1}$, until all
arguments of the $\psi$ function are processed. When all arguments
are processed, the $\psi$ is in its normalized form. When all $\psi$
functions are processed, the function will contain only
normalized-$\psi$ functions.

%% The top-down traversal of the dominator tree will ensure that when a
%% variable in a $\psi$ function is defined by another $\psi$ function,
%% this $\psi$ function has already been analyzed and put in its
%% normalized form. Thus the definition of its first variable already
%% dominates the definitions for the other arguments of the $\psi$
%% function.

\subsection{Psi-web}

In this pass, we repair the $\psi$ functions when variables cannot be
put into the same $\psi$-SSA web, because their live ranges
interfere. This case corresponds to the example presented in
figure~\ref{fig:psi_interference}(g).

In the same way as there is a specific point of use for arguments on
$\phi$ functions for liveness analysis, we give a definition of the
actual point of use of arguments on $\psi$ functions for liveness
analysis. With this definition, liveness analysis will be computed
accurately and an interference graph can be built.

%\SubSubSection{Liveness and interferences in Psi-SSA}
\paragraph{Liveness and interferences in Psi-SSA.}
We have already shown in figure~\ref{fig:psi_interference}(g) that
repair code may be needed so that the arguments and definition of a
$\psi$ function can be renamed into a single name. We first give a
definition of the point of use of the arguments in a $\psi$ function
such that liveness analysis can be accurately computed. With this
liveness, the cases where repair code is needed can be easily and
accurately detected by observing that live-ranges for variables in a
$\psi$ function overlap.

Consider the code in figure~\ref{fig:psi_ccond} (b). Instead of using
a representation with $\psi$ functions, predicated definitions have
been modified to make a reference to the value the predicated
definition will have in case the predicate is false. We use in this
example the notation of the C conditional operator ${\tt x = cond ?
  exp1 : exp2}$. Each of the predicated definitions make an explicit
use of the variable immediately to its left in the argument list of
the original $\psi$ function from figure~\ref{fig:psi_ccond} (a). We
can see that a renaming of the variables {\tt a}, {\tt b}, {\tt c} and
{\tt x} into a single representative name will still compute the same
value for the variable {\tt x}. Note that this transformation can only
be performed on normalized $\psi$ functions, since the definition of
an argument must be dominated by the definition of the argument
immediately at its left in the argument list of the $\psi$
function. Using this equivalence for the representation of a $\psi$
function, we now give a definition of the point of use for for the
arguments of a $\psi$ function.

{\bf Definition} {\em We say that the point of use of an argument in a
  normalized $\psi$ function occurs at the point of definition of the
  argument immediately at its right in the argument list of the $\psi$
  function. For the last argument of the $\psi$ function, the point of
  use occurs at the $\psi$ function itself. }

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llll}
           & ${\tt a = op1}$ & \ \ \ \ & ${\tt a = op1}$ \\
${\tt p?}$ & ${\tt b = op2}$ & \ \ \ \ & ${\tt b = p\ ?\ op2\ :\ a}$ \\
${\tt q?}$ & ${\tt c = op3}$ & \ \ \ \ & ${\tt c = q\ ?\ op3\ :\ b}$ \\
           & ${\tt x = Psi(a,p?b,q?c)}$ & \ \ \ \ & ${\tt x = c}$ \\
\\
\multicolumn{2}{l}{\tt {\bf (a) Psi-SSA form}} & \ \ \ \ & {\tt {\bf (b) C conditional form}}
\end{tabular}
\caption{$\psi$ functions and C conditional operations equivalence}
\label{fig:psi_ccond}
\end{center}
\end{figure}

Given this definition of point of use of $\psi$ arguments, and using
the usual point of use of $\phi$ arguments, a traditional liveness
analysis can be run. Then an interference graph can be built to
collect the interferences between variables involved in $\psi$ or
$\phi$ functions. For the construction of the interference graph, an
interference between two variables that are defined on disjoint
predicates can be ignored.

%\SubSubSection{Repairing interferences on $\psi$ operations}
\paragraph{Repairing interferences on $\psi$ functions.}
We now present an algorithm that creates $\psi$-SSA webs from $\psi$
functions such that there are no interference between two variables in
the same $\psi$-SSA web.

First, the $\psi$-SSA webs are initialized such that each variable in
the $\psi$-SSA representation belongs to its own $\psi$-SSA web. Then,
$\psi$ functions are processed one at a time, in no specific order. A
pseudo-code of this algorithm is given in
figure~\ref{fig:pseudo_psi_repair}.

The analysis of a $\psi$ function starts by setting the current
$\psi$-SSA web to the $\psi$-SSA web of the result of the $\psi$
function. Then, the arguments of the $\psi$ function are processed
from right to left. The $\psi$-SSA web for an argument can be merged
into the current $\psi$-SSA web if these two $\psi$-SSA web do not
interfere. Two $\psi$-SSA webs interfere if at least one variable in
the first $\psi$-SSA web interferes with at least one variable in the
other one.

If the $\psi$-SSA web for an argument ${\tt a_i}$ does not interfere
with the current $\psi$-SSA web, then the two $\psi$-SSA webs are
merged. Otherwise, the $\psi$-SSA web for the argument ${\tt a_i}$
cannot be merged with the current $\psi$-SSA web, and repair code is
needed. A new variable, ${\tt a'_i}$, is created and is initialized
with a predicated copy ${\tt p_i? a'_i = a_i}$, inserted just below
the definition for ${\tt a_i}$. The current argument ${\tt a_i}$ in
the $\psi$ function is replaced by the new variable ${\tt a'_i}$. The
interference graph is updated with an interference between ${\tt a_i}$
and ${\tt a'_i}$. Also, conservatively, ${\tt a'_i}$ is considered to
be interfering with all the variables ${\tt a_i}$ interfere with,
except with those variables in the current $\psi$-SSA web. The
conservative update of the interference graph may increase the number
of copies generated during the conversion to the $\psi$-CSSA form.

Then the algorithm proceeds with the next argument on the left until
all arguments are processed.

\begin{figure}
\begin{center}
\footnotesize
PsiOp\_mergeSSAWebs(psiOp) { \\
\\
\ \ psiWeb = SSAWeb\_get(psiOp->result()) \\
\\
\ \ for (i = psiOp->opndCount()-1; i >= 0; i--) { \\
\\
\ \ \ \ psiOpnd = psiOp->opnd(i); \\
\ \ \ \ psiOpndWeb = SSAWeb\_get(psiOpnd); \\
\\
\ \ \ \ if (IGraph\_interferes(psiWeb, psiOpndWeb)) { \\
\ \ \ \ \ \ newOpnd = newVar(); \\
\ \ \ \ \ \ newOp = newCopy(newOpnd, psiOp->predicate(i), psiOpnd); \\
\ \ \ \ \ \ InsertOpAfter(newOp, psiOpnd->defOp()); \\
\ \ \ \ \ \ psiOp->opnd(i) = newOpnd; \\
\ \ \ \ \ \ psiOpndWeb = SSAWeb\_get(newOpnd); \\
\\
\ \ \ \ \ \ IGraph\_addInterference(newOpnd, psiOpnd); \\
\ \ \ \ \ \ forall var in IGraph\_interferenceSet(psiOpnd) { \\
\ \ \ \ \ \ \ \ if (!SSAWeb\_contain(psiWeb, var)) \\
\ \ \ \ \ \ \ \ \ \ IGraph\_addInterference(newOpnd, var); \\
\ \ \ \ \ \ } \\
\ \ \ \ } \\
\\
\ \ \ \ psiWeb = SSAWeb\_union(psiWeb, psiOpndWeb); \\
\ \ } \\
} \\
\\
\caption{Merging $\psi$-SSA webs on a $\psi$ function}
\label{fig:pseudo_psi_repair}
\end{center}
\end{figure}

% Some comments on an exact interference graph update ??

Consider the code in figure~\ref{fig:live_interference} to see how
this algorithm works. The liveness on the $\psi$ function creates a
live-range for variable {\tt a} that extends down to the definition of
{\tt b}, but not further down. Thus, the variable {\tt a} does not
interfere with the variables {\tt b}, {\tt c} or {\tt x}. The
live-range for variable {\tt b} extends down to its use in the
definition of variable {\tt d}. This live-range interferes with the
variables {\tt c} and {\tt x}. The live-range for variable {\tt c}
extends down to its use in the $\psi$ function that defines the
variable ${\tt x}$.

At the beginning of the processing on the $\psi$ function ${\tt x =
  Psi(p?a,q?b,r?c)}$, all variables belong to their own $\psi$-SSA
web. The current $\psi$-SSA web is set to the $\psi$-SSA web of the
result, ${\tt \{x\}}$. Then the argument list is processed from right
to left. Variable ${\tt c}$ does not interfere with current $\psi$-SSA
web ${\tt \{x\}}$, they can be merged together, resulting in a current
$\psi$-SSA web ${\tt \{x, c\}}$. Then, variable ${\tt b}$ is
processed. Since it interferes with both ${\tt x}$ and ${\tt c}$,
repair code is needed. A variable ${\tt b'}$ is created, and is
initialized just below the definition for ${\tt b}$, as a predicated
copy of ${\tt b}$. The interference graph is updated, only an
interference between ${\tt b'}$ and ${\tt b}$ is added. The current
$\psi$-SSA web now becomes ${\tt \{x, b', c\}}$. Then variable ${\tt
  a}$ is processed and inserted into the current $\psi$-SSA web. The
final code after SSA destruction is shown in
figure~\ref{fig:live_interference} (c).

\begin{figure}
\begin{center}
\footnotesize
\begin{tabular}{llllll}
${\tt p?}$ & ${\tt a = ...}$              & ${\tt p?}$ & ${\tt a = ...}$                 & ${\tt p?}$ & ${\tt x = ...}$\\
${\tt q?}$ & ${\tt b = ...}$              & ${\tt q?}$ & ${\tt b = ...}$                 & ${\tt q?}$ & ${\tt b = ...}$\\
           &                              & ${\tt q?}$ & ${\tt b' = b}$                  & ${\tt q?}$ & ${\tt x = b}$\\
${\tt r?}$ & ${\tt c = ...}$              & ${\tt r?}$ & ${\tt c = ...}$                 & ${\tt r?}$ & ${\tt x = ...}$ \\
           & ${\tt x = Psi(p?a,q?b,r?c)}$ &            & ${\tt x = Psi(p?a,q?b',r?c)}$   &            & \\
${\tt s?}$ & ${\tt d = b+1}$              & ${\tt s?}$ & ${\tt d = b+1}$                 & ${\tt s?}$ & ${\tt d = b+1}$ \\
\\
\multicolumn{2}{l}{${\tt{\bf (a)\ before\ \psi\ processing}}$} & \multicolumn{2}{l}{${\tt{\bf (b)\ after \psi\ processing}}$} & \multicolumn{2}{l}{${\tt{\bf (b)\ after \psi\ renaming}}$} \\
\end{tabular}
\caption{Elimination of $\psi$ live-interference}
\label{fig:live_interference}
\end{center}
\end{figure}

\subsection{Phi-web}

When all $\psi$ functions are processed, the $\psi$-SSA webs built
from $\psi$ functions are extended to include the variables in $\phi$
functions. In this part, the algorithm presented in
chapter~\ref{chap:alternative_destruction} is used, with a few
modifications.

The first modification is that the $\psi$-SSA webs must not be
initialized at the beginning of this process. They have already been
initialized at the beginning of the $\psi$-web step, and were extended
during the processing of $\psi$ functions. These webs will be extended
now with $\phi$ functions during this step.

The second modification is that the live-analysis run for this part
must also take into account the special liveness rule on the $\psi$
functions. The reason for this is that for any two variables in the
same $\psi$-SSA web, any interference, either on a $\psi$ or on a
$\phi$ function, will not preserve the correct semantics if the
variables are renamed into a representative name.

All other parts of the SSA destruction algorithm from
chapter~\ref{chap:alternative_destruction} are unchanged, and in
particular, any of the three algorithms described for the conversion
into a CSSA form can be used.

We have described a complete algorithm to convert a $\psi$-SSA
representation into a $\psi$-CSSA representation. The final step to
convert the code into a non-SSA form is a simple renaming of all the
variables in the same $\psi$-SSA web into a representative name. The
$\psi$ and $\phi$ functions are then removed.

%% \paragraph{Interference with the result of a $\psi$ function.}

%% When the live-range for an argument of a $\psi$ function overlaps
%% with the live-range of the variable defined by the $\psi$ function,
%% this interference can be ignored. Actually, there are two cases to
%% consider:

%% \begin{itemize}
%% \item If the argument is not the last one in the $\psi$ function, and
%% its live-range overlaps with the live-range of the definition of the
%% $\psi$ function, then this live-range also overlaps with the
%% live-range of the last argument. Thus this interference will already
%% be detected and repaired.

%% \item If the argument is the last one of the $\psi$ function, then
%% the value of the $\psi$ function is the value of this last argument,
%% and this argument and the definition will be renamed into the same
%% variable out of the SSA representation. Thus, there is no need to
%% introduce a copy here.
%% \end{itemize}


\section{Additional reading}

More details on the implementation of the $psi$-SSA algorithms, and
figures on the benefits of this representation, are published in
\cite{Stouchinin2001} and \cite{deferriere2006}.



The early literature on SSA form
\cite{cytron89efficiently,cytron91efficiently}
introduces the construction algorithm we have outlined in this chapter,
and discusses its algorithmic complexity on common and worst-case inputs.

There are numerous published descriptions of alternative algorithms.
One of the most unconventional, which is striking for its elegant simplicity,
is presented by Aycock
and Horspool \cite{aycock00simple}. 
This is a pessimistic SSA construction technique,
in that it initially assumes $\phi$-functions are required
for all variables at all control flow merge points. 
It proceeds to remove unnecessary $\phi$-functions 
using simple rewrite rules.

Sreedhar and Gao \cite{sreedhar95linear} pioneered
linear-time complexity construction algorithms based on DJ-graphs.
Their work has since been refined by other researchers.
Chapter \ref{chap:alternative_ssa_construction_algorithms}
explores these more efficient algorithms in depth.


%%% FAB: we should probably move the technical discussions to this part?
%%% At least, put all the external references here (eg Cytron, etc.)
%%% TODO: write this section
Should cite (at least):
\begin{itemize}
\item Cytron for original construction and Aycock for minimality/simple construction and also reference to Semantic chapter (for minimality they have a similar copy-prop algo in the context of functional programming; for construction and dominance notion they have a nice equivalence with functional programming again) 
\item Wolf (J+=J) for join set
\item Sreedhar Gao (linear time algo) for properties on DJ-graphs, DF-graphs and dominance tree \& Ramalingam (loops, dom, dom-tree) for loop nesting forest dom-tree and DF \& reference to advanced SSA construction
\item Sreedhar's paper \& Glessner for basic correct SSA destruction \& reference to advanced destruction chapter. Maybe a brief history with previous ``incorrect papers''.
\item Sreedhar Lee Gao \& Ramalingam (incremental dom-tree) for the maintain of the dom-tree (maybe should ask Sebastian to put it in his chapter instead)
\end{itemize}
