\chapter{Introduction \Author{M. Schordan and F. Rastello}}
\label{chapter:analysis}
\inputpath{part3}{analysis}
\inputprogress

The goal of this chapter is to provide an overview of the benefits of SSA for diverse program analysis.
We will talk about alias analysis that do not have its own chapter but also GV-PRE of Van Drunen that subsums the SSA-PRE of F. Chow.
We will finally also list the chapters of this part.

\section{Propagation Engine}
In this sections we illustrate how SSA makes several analysis convenient mostly because of its similarity to functional programs. 
Technically the def-use chains explicitely expressed through the SSA graph but also the static-single information property (that mainly comes from the single definition property and the fact that most properties come from definitions) is what makes SSA so convenient.
There are several analysis that propagate information through the SSA graph.
The \emph{chapter ``propagation engine''}\ref{chapter:constant_propagation_is_easier} gives a somehow general description of the mechanism.
The \emph{``chapter on scalar evolution''}\ref{chapter:loop_tree} illustrates also this approach by capturing properties of the graph itself (circuits).
Global value numbering like algorithms such as the one descibed at the end of chapter ``PRE''\ref{chapter:pre_not_helped} but also the more general PRE of \emph{Van Drunen} is also a perfect illustrattion.
We roughly describe this last algorithm here.

\section{Structural properties}
As already mentioned in Chapter~\ref{chapter:properties_and_favors}, can come in different flavors. 
Vanilla one, is strict SSA, or said equivalently, SSA with dominance property. 
The most common SSA construction algorithm, exploits this dominance property by two means: 
First it allows to compute join sets for \phifun\ placement in a very efficient way using the dominance frontier. 
Second it allows variable renaming using a folding scheme along the dominance tree. 
The notion of dominance and dominance frontier are two structural properties that make SSA form singular for compiler analysis and transformations. 
Those two aspects are illustrated in this part through two chapters: 
Chapter~\ref{chapter:ssa_tells_nothing_of_liveness} shows how loop nesting forest and dominance property can be exploited to devise very efficient liveness analysis;
Chapter~\ref{chapter:pre_not_helped} shows how dominance frontier that allows to insert minimal number of \phifun\ for SSA construction can also be used to minimize redundant computations.

\paragraph{Liveness}
SSA simplifies, accelerates liveness analysis.
Ususal approach: data-flow abnalysis iteratively (potentially as many times as max loop depth).
Live-in of a loop, then live everywhere in the loop.
Dominance => live everywhere in a loop then live-in of a loop.
live-in of a loop in the CFG then also live-in of loop in forward CFG (and reciproquely) => compute all loop headers where variable is alive using data-flow (without any iterations).
Chapter presents also two other approaches: 1. path exploration (variable live if belongs path from definition to use -- SSA does not help much for this algorithm but for sumarising better liveness within a BB); 2. 


live-range has following property: v live at program point q if and only if v is live at the entry of the largest loop/basic-block that contains q but not the definition of v; v is live at h if and only if there is a path in the forward-CFG from h to a use of v that does not contain the definition.


An interesting In this section we illustrate how the structural properties of SSA are useful. 
The first one is the dominance property whic underlying tree structure is really interesting. 
We can do any greedy or dynamic programming along this tree. 
We illustrate the advantages of dominance property on \emph{liveness analysis} and check. 

\paragraph{Partial Redundancy Elimination}
The second property is related to the dominance frontier that actually turn out to be the ``frontier of redundancy''. 
It is not the SSA form itself that is interesting at that point but the formalism introduced to the construction of SSA that we use. 
This is illustrated through the\emph{chapter on SSAPRE}\ref{chapter:pre_not_helped}.

\section{Sparse Analysis}
In this section we illustrate through an important problem (\emph{alias analysis}) how SSA really helps in having effective analysis on complex problems. 
This is about sparsity (as mentioned in chapter ``Properties of SSA'') which is provided by the SSA form as an ``optimal'' (minimal size) sparse evaluation graph. 
For that we report the work of Ben and Li on sparse analysis. 
We take the opportunity to outline that we can start from (partial) SSA as top level variables already provide insightful information for this analysis. 
I we believe other variables (that alias with others) must be used for this analysis, and want fully sparse analysis then we need to consider SSA extensions such as HSSA.





