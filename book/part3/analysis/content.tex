\chapter{Introduction \Author{M. Schordan and F. Rastello}}
\inputpath{part3}{analysis}
\inputprogress

The goal of this chapter is to provide an overview of the benefits of SSA for diverse program analysis.
We will talk about alias analysis that do not have its own chapter but also GV-PRE of Van Drunen that subsums the SSA-PRE of F. Chow.
We will finally also list the chapters of this part.

\section{Propagation Engine}
In this sections we illustrate how SSA makes several analysis convenient mostly because of its similarity to functional programs. 
Technically the def-use chains explicitely expressed through the SSA graph but also the static-single information property (that mainly comes from the single definition property and the fact that most properties come from definitions) is what makes SSA so convenient.
There are several analysis that propagate information through the SSA graph.
The \emph{chapter ``propagation engine''} gives a somehow general description of the mechanism.
The \emph{``chapter on scalar evolution''} illustrates also this approach by capturing properties of the graph itself (circuits).
Global value numbering like algorithms such as the one descibed at the end of chapter ``PRE'' but also the more general PRE of \emph{Van Drunen} is also a perfect illustrattion.
We roughly describe this last algorithm here.

\section{Structural properties}
In this section we illustrate how the structural properties of SSA are useful.
The first one is the dominance property whic underlying tree structure is really interesting.
We can do any greedy or dynamic programming along this tree.
We illustrate the advantages of dominance property on \emph{liveness analysis} and check.
The second property is related to the dominance frontier that actually turn out to be the ``frontier of redundancy''.
It is not the SSA form itself that is interesting at that point but the formalism introduced to the construction of SSA that we use.
This is illustrated through the\emph{ chapter on SSAPRE}

\section{Sparse Analysis}
In this section we illustrate through an important problem (\emph{alias analysis}) how SSA really helps in having effective analysis on complex problems.
This is about sparsity (as mentioned in chapter ``Properties of SSA'') which is provided by the SSA form as an ``optimal'' (minimal size) sparse evaluation graph.
For that we report the work of Ben and Li on sparse analysis.
We take the opportunity to outline that we can start from (partial) SSA as top level variables already provide insightful information for this analysis.
I we believe other variables (that alias with others) must be used for this analysis, and want fully sparse analysis then we need to consider SSA extensions such as HSSA.





