\chapter{additional gain from psi ssa \Author{F. de Ferri\`ere}}
\numberofpages{3.5}

\chapterauthor{de Ferri\`ere}


\TODO{note overlap with Stannier in VSDG chapter}

\section{Overview}

\textbf{0.5 page}

Recall the equivalence between PHI operations on control-flow path and PSI operations on predicated code.


\section{Optimizations}

\textbf{3 page}

Psi-SSA allows to optimize code that is not the result of if-conversion, such as inlining of intrinsic functions or peephole transformations. In these cases, usual ssa optimizations can be applied on predicated code, such as constant propagation, dead-code elimination or value numbering.

Psi-SSA can also enable some optimizations after if-conversion that are difficult to perform before if-conversion, thanks to the psi-projection. On control flow, such transformations would create non strict SSA.

Other transformations on PSI operations are equivalent to transformations on PHI operations with control flow, such as predicate promotion and speculation. Give hints on why these optimizations are better performed before or after if-conversion.

Finally, psi-SSA gives flexibility in the phasing of the optimizations, since predicated code and if-conversion is non longer a barrier. Optimizations can be implemented to run efficiently before or after the generation of predicated instructions.

Gives some figure on cycle count and code size reduction with optimizations on predicated code using psi-ssa.
