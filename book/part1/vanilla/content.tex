%% \chapter{Introduction \Author{J. Singer}\\\progressbar[0.4\textwidth]{draft}{70}}
\chapter{Introduction \Author{J. Singer}}


%%%%%%%%%%%

\section{motivation}


% Possibility of unique names for distinct entities.
% Maybe a slightly humorous example, involving Homer Simpson and
% Homer the classical Greek poet. Convey the point that,
% without unique names, extra \textit{context} is required
% to make the name useful.
% (Springfield or Greece?)

In computer programming, as in real life, 
names are useful handles for concrete entities.
% Discuss the utility of names as abstract identifiers.
The key message of this book is that
having \textit{unique names} for
\textit{distinct entities}
reduces uncertainty and imprecision.

For example, consider overhearing a conversation
about `Homer.' Without any more contextual clues, you
cannot disambiguate between Homer Simpson and Homer the
classical Greek poet; or indeed, any other people
called Homer that you may know.
As soon as the conversation mentions Springfield
(rather than Smyrna), you are fairly sure that the
Simpsons television series (rather than Greek poetry)
is the subject.
On the other hand, if everyone had a \textit{unique} name,
then there would be no possibility of confusing 20th century
American cartoon characters with ancient Greek poets.
\textit{Could we have a cartoon picture here?}

% where SSA is applied, in compiler intermediate representations...
This book is about the \textit{static single assignment form} (SSA),
which is a naming convention for variables in low-level representations
of computer programs.
A program is said to be in SSA form when each variable is defined (hence
\textit{assignment})
exactly once (hence \textit{single}) in the program text
(hence \textit{static}).

There are some high-level languages that enforce
a single-assignment property (examples: SISAL, Java \texttt{final} variables). 
(also mention link between SSA and functional programming -
referential transparency. All FP languages support single assignment
(\texttt{val} not \texttt{var}) as default.
However in general,
it is straightforward to translate a non-SSA program into an SSA
program. (Links to appropriate chapters here?
Simple construction / Advanced construction chapters.)

Why is it important for compilers to have SSA-based IRs? Simple motivation
(i) Strict discipline on namespace. 
Each variable has a unique definition point.
(ii) Namespace explicitly reflects points where values from
different control-flow paths merge. 
These properties serve to simplifies variable def-use relationships,
which underpin data flow analysis.
(then link to appropriate chapters later in book.)
Advantages gained from these properties...
\begin{enumerate}
\item Certain compiler optimizations can be more effective
when operating on programs in SSA form
(examples - control-flow-insensitive
analyses)
\item Certain compiler optimizations can be more efficient
when operating on SSA programs (examples?) 
\item Compiler analyses and transformations can be easier
to express in SSA - software engineering benefit. Better
for debugging, productivity, etc. (examples?)
\end{enumerate}


%%%%%%%%%%%

\section{informal semantics (with examples)}


Given a simple pseudo-code language, show examples of programs in SSA.
(Should I show before/after SSA transformation, or just programs
in SSA form already? Fabrice suggests before/after... plus
one or two sentences commentary on each.)

example 1. Straightline code. (sequence)

\begin{verbatim}
x = 1;
y = 2;
x = x+y;
\end{verbatim}

example 2. if/then/else conditional.  (selection)

\begin{verbatim}
x = input();
if (x == 42)
  y = 1;
else
  y = x*2;
print(y)
\end{verbatim}

(Explain carefully how $\phi$-functions work.) 
A $\phi$-function is a special statement, known as a
\textit{pseudo-assignment}.
Appel \cite{appelbook} refers to it as a `notational fiction.'
The purpose of a $\phi$-function is to merge
incoming values from different control flow predecessors.
At the start of a basic block of code, the $\phi$-function has
$n$ parameters if there are $n$ incoming control flow edges to this block.
When the $\phi$-function is evaluated, it selects the value
of the parameter associated  with the actually executed control-flow path.
This value is assigned to the fresh variable name, on the left-hand-side
of the $\phi$-function.
These pseudo-assignments are required to maintain the SSA property
of unique variable definitions,
in the presence of non-sequential (non-linear?) control flow.

It is important to note that, if there are multiple $\phi$-functions
at the head of a basic block, then these are executed simultaneously,
\textit{not} one after another.
This distinction becomes important if the destination of a $\phi$-function
is the same as the source of another $\phi$-function, perhaps after
optimizations such as copy propagation.

Strictly speaking, $phi$-functions are not directly executable,
since the dynamic control-flow path leading to the $\phi$-function
is not explicitly encoded as an input to $\phi$-function.
($\phi$-fn used for analysis of program, but not for any
interpretation / execution.)
There are various executable extensions of $\phi$-functions, 
such as $\gamma$-functions, which take
an extra parameter to specify which rvalue to assign to the lvalue.
(forward ref to VSDG chapter?)

When we eliminate $\phi$-functions in the conversion out of SSA form,
they are replaced by parallel copy operations at the end of predecessor
control flow nodes. (forward note to Fabrice's section on this,
in later chapter).

(Perhaps put in a footnote about how $\phi$-functions were
called \textit{phoney}-functions at IBM during the development
of SSA - as reported by Kenny Zadeck.)
example 3. while loop? (iteration)

\begin{verbatim}
x = 0;
y = 0;
while (x< 10) {
  y = y + x;
  x++;
}
print(y)
\end{verbatim}



%%%%%%%%%%%

\section{definition}


The original paper on SSA gives an informal
definition as follows:

\begin{quotation}
A single program is defined to be in SSA
form if each variable is a target of
exactly one assignment statement in the
program text.
\end{quotation}

% Informally, static means `program text.'
% single means `unique names'
% assignment means `at variable definitions.'

%% Again, informally, unique definition for each variable.

This is the simplest definition of SSA. However
there are various, more specialized, varieties of SSA,
which impose further constraints on programs.
These constraints are generally expressed in terms
of dominance properties of variable definitions, or
the presence/absence of certain 
$\phi$-functions at control-flow merge points.
% Formally, in terms of dominance. Each var has a unique
% definition, and def dominates all uses.
% Perhaps require implicit defs of all vars at entry,
% implicit uses of all vars at exit?
Each distinct SSA flavour has specific properties---many of
these are discussed in Chapter \ref{FIXME} 2.
% forward links to Philip's discussion of
% SSA flavours and properties here

One important property that holds for all forms of SSA,
including the simple definition above, is 
\emph{referential transparency}.
Since there is only a single definition for each variable
in the program text, we can be sure of that variable's value
regardless of its position in the program.
Programs written in pure functional languages
are referentially transparent.

Referentially transparent programs are more amenable to 
formal methods and mathematical reasoning since
the meaning of an expression depends only on the
meaning of its subexpressions
and not on the order of evaluation or
side-effects of other expressions.

For a hideously referentially opaque program, consider
the following fragment of C code, which has of side-effecting
expression evaluations and an explicitly undefined evaluation order. 
\begin{verbatim}
x = 1;
x = x++ + ++x;
\end{verbatim}

When this code is transformed to SSA-based three-address code,
it becomes referentially transparent. The translation process has
imposed a specific evaluation order and replaced side-effecting
expressions with intermediate values.
\begin{verbatim}
x1 = 1;
x2 = x1 + 1;
x3 = x2 + 1;
x4 = x2 + x3;
\end{verbatim}


% "The most important feature of mathematical notation is that an expression is used solely to describe (or denote) a value. In other words, the meaning of an expression is its value and there are no other effects, hidden or otherwise, in any procedure for actually obtaining it. Furthermore, the value of an expression depends only on the values of its constituent expressions (if any) and these subexpressions may be replaced freely by others possessing the same value. ... The characteristic property of mathematical expressions described here is called "referential transparency." Bird, Richard, and Wadler, Philip; Introduction to Functional Programming, p. 4; Prentice Hall, 1988.


%%%%%%%%%%%

\section{brief history}


% Crib most of this from Kenneth Zadeck. 

% Talk about other program dependence graph
% representations, 

Throughout the 1980s, various compiler intermediate
representations were proposed to encapsulate data
dependence, in a way that enabled fast and accurate
data flow analysis.
The key property that motivated the design of
such IRs was the exposure of variable \textit{def-use} 
information, with standardized shapes for
\textit{def-use chains}, and the ability
to propagate data flow information efficiently
from definitions to uses,
and vice versa.
(examples, program dependence graph, program dependence web).
(perhaps a forward pointer to 
VSDG chapter?)

% Talk about early developments at IBM in 1980s.
% Talk about eventual emergence of SSA.

Static single assignment form was one of these IRs, 
which was developed at IBM Research, and publicly announced
in several research papers in the late 1980s. (cites)
SSA rapidly gained popularity due to its 
intuitive nature and straightforward
construction/implementation.

The majority of current commercial and open-source compilers
use SSA as a key intermediate representation for
program optimization.

SSA - for heavy-duty optimizations.
For JIT compilers - hot methods.
For static compilers, high-level optimization. (-O3?)

GCC and SSA. - brief outline of history. (Case study?)

%%%%%%%%%%%

\section{comparison with dataflow analysis (high level overview of DFA)}


Very simple. Discuss lattice-based data flow analysis.
Propagating facts around control-flow points in a CFG.

Talk about SSA simplification - rename whenever data flow
facts can change (for a certain class of data flow problems?)
so, can associate facts directly with names, rather than with
name at point.
Plain SSA - rename at variable definitions - so any data flow
analysis where data flow properties change only with definitions
(e.g. constant propagation) OK. Other data flow properties may 
change at other points - can still fit these neatly into the SSA
analysis framework by inserting additional pseudo-definitions
to rename variables. examples? (forward pointers).


%%%%%%%%%%%
