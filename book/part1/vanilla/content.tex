\chapter{Introduction \Author{J. Singer}}
\numberofpages{10}
\chapterauthor{Singer}

\textbf{total page count for chapter: 10 pages}

%%%%%%%%%%%

\section{motivation}

\textbf{1 page}

% Possibility of unique names for distinct entities.
% Maybe a slightly humorous example, involving Homer Simpson and
% Homer the classical Greek poet. Convey the point that,
% without unique names, extra \textit{context} is required
% to make the name useful.
% (Springfield or Greece?)

In computer programming, as in real life, 
names are useful handles for concrete entities.
% Discuss the utility of names as abstract identifiers.
The key message of this book is that
having \textit{unique names} for
\textit{distinct entities}
reduces uncertainty and imprecision.

For example, consider overhearing a conversation
about `Homer.' Without any more contextual clues, you
cannot disambiguate between Homer Simpson and Homer the
classical Greek poet; or indeed, any other people
called Homer that you may know.
As soon as the conversation mentions Springfield
(rather than Smyrna), you are fairly sure that the
Simpsons television series (rather than Greek poetry)
is the subject.
On the other hand, if everyone had a \textit{unique} name,
then there would be no possibility of confusing 20th century
American cartoon characters with ancient Greek poets.
\textit{Could we have a cartoon picture here?}

% where SSA is applied, in compiler intermediate representations...
This book is about the \textit{static single assignment form} (SSA),
which is a naming convention for variables in low-level representations
of computer programs.
A program is said to be in SSA form when each variable is defined (hence
\textit{assignment})
exactly once (hence \textit{single}) in the program text
(hence \textit{static}).

There are some high-level languages that enforce
a single-assignment property (examples: SISAL, Java \texttt{final} variables). 
(also mention link between SSA and functional programming -
referential transparency. All FP languages support single assignment
(\texttt{val} not \texttt{var}) as default.
However in general,
it is straightforward to translate a non-SSA program into an SSA
program. (Links to appropriate chapters here?
Simple construction / Advanced construction chapters.)

Why is it important for compilers to have SSA-based IRs? Simple motivation
(i) Strict discipline on namespace. 
Each variable has a unique definition point.
(ii) Namespace explicitly reflects points where values from
different control-flow paths merge. 
These properties serve to simplifies variable def-use relationships,
which underpin data flow analysis.
(then link to appropriate chapters later in book.)
Advantages gained from these properties...
\begin{enumerate}
\item Certain compiler optimizations can be more effective
when operating on programs in SSA form
(examples - control-flow-insensitive
analyses)
\item Certain compiler optimizations can be more efficient
when operating on SSA programs (examples?) 
\item Compiler analyses and transformations can be easier
to express in SSA - software engineering benefit. Better
for debugging, productivity, etc. (examples?)
\end{enumerate}


%%%%%%%%%%%

\section{informal semantics (with examples)}

\textbf{3 pages}

Given a simple pseudo-code language, show examples of programs in SSA.
(Should I show before/after SSA transformation, or just programs
in SSA form already? Fabrice suggests before/after... plus
one or two sentences commentary on each.)

example 1. Straightline code. (sequence)

\begin{verbatim}
x = 1;
y = 2;
x = x+y;
\end{verbatim}

example 2. if/then/else conditional.  (selection)

\begin{verbatim}
x = input();
if (x == 42)
  y = 1;
else
  y = x*2;
print(y)
\end{verbatim}

(Explain carefully how $\phi$-functions work.) 
A $\phi$-function is a special statement, known as a
\textit{pseudo-assignment}.
Appel \cite{appelbook} refers to it as a `notational fiction.'
The purpose of a $\phi$-function is to merge
incoming values from different control flow predecessors.
At the start of a basic block of code, the $\phi$-function has
$n$ parameters if there are $n$ incoming control flow edges to this block.
When the $\phi$-function is evaluated, it selects the value
of the parameter associated  with the actually executed control-flow path.
This value is assigned to the fresh variable name, on the left-hand-side
of the $\phi$-function.
These pseudo-assignments are required to maintain the SSA property
of unique variable definitions,
in the presence of non-sequential (non-linear?) control flow.

It is important to note that, if there are multiple $\phi$-functions
at the head of a basic block, then these are executed simultaneously,
\textit{not} one after another.
This distinction becomes important if the destination of a $\phi$-function
is the same as the source of another $\phi$-function, perhaps after
optimizations such as copy propagation.

Strictly speaking, $phi$-functions are not directly executable,
since the dynamic control-flow path leading to the $\phi$-function
is not explicitly encoded as an input to $\phi$-function.
($\phi$-fn used for analysis of program, but not for any
interpretation / execution.)
There are various executable extensions of $\phi$-functions, 
such as $\gamma$-functions, which take
an extra parameter to specify which rvalue to assign to the lvalue.
(forward ref to VSDG chapter?)

When we eliminate $\phi$-functions in the conversion out of SSA form,
they are replaced by parallel copy operations at the end of predecessor
control flow nodes. (forward note to Fabrice's section on this,
in later chapter).

(Perhaps put in a footnote about how $\phi$-functions were
called \textit{phoney}-functions at IBM during the development
of SSA - as reported by Kenny Zadeck.)
example 3. while loop? (iteration)

\begin{verbatim}
x = 0;
y = 0;
while (x< 10) {
  y = y + x;
  x++;
}
print(y)
\end{verbatim}



%%%%%%%%%%%

\section{definition}

\textbf{1.5 pages}

Informally, static means `program text.'
single means `unique names'
assignment means `at variable definitions.'

Again, informally, unique definition for each variable.

Formally, in terms of dominance. Each var has a unique
definition, and def dominates all uses.
Perhaps require implicit defs of all vars at entry,
implicit uses of all vars at exit?

Probably need forward links to Philip's discussion of
SSA flavours and properties here.

Talk about the virtue of referential transparency. A single
definition for each variable - means that we can be sure
of that variable's value independent of its
position in the program. cf functional programming.

%%%%%%%%%%%

\section{brief history}

\textbf{1.5 pages}

Crib most of this from Kenneth Zadeck. 
Talk about early developments at IBM in 1980s.
Talk about eventual emergence of SSA.
Talk about other program dependence graph
representations, perhaps a forward pointer to 
VSDG chapter.

The majority of commercial and open-source compilers
now use SSA as a key intermediate representation for
program optimization.

%%%%%%%%%%%

\section{comparison with dataflow analysis (high level overview of DFA)}

\textbf{3 pages}

Very simple. Discuss lattice-based data flow analysis.
Propagating facts around control-flow points in a CFG.

Talk about SSA simplification - rename whenever data flow
facts can change (for a certain class of data flow problems?)
so, can associate facts directly with names, rather than with
name at point.
Plain SSA - rename at variable definitions - so any data flow
analysis where data flow properties change only with definitions
(e.g. constant propagation) OK. Other data flow properties may 
change at other points - can still fit these neatly into the SSA
analysis framework by inserting additional pseudo-definitions
to rename variables. examples? (forward pointers).


%%%%%%%%%%%
