\chapter{Introduction \Author{J. Singer}}
\numberofpages{10}
\chapterauthor{Singer}

\textbf{total page count for chapter: 10 pages}

%%%%%%%%%%%

\section{motivation}

\textbf{1 page}

% Possibility of unique names for distinct entities.
% Maybe a slightly humorous example, involving Homer Simpson and
% Homer the classical Greek poet. Convey the point that,
% without unique names, extra \textit{context} is required
% to make the name useful.
% (Springfield or Greece?)

In computer programming, as in real life, 
names are useful handles for concrete entities.
% Discuss the utility of names as abstract identifiers.
The key message of this book is that
having \textit{unique names} for
\textit{distinct entities}
reduces uncertainty and imprecision.

For example, consider overhearing a conversation
about `Homer.' Without any more contextual clues, you
cannot disambiguate between Homer Simpson and Homer the
classical Greek poet; or indeed, any other people
called Homer that you may know.
As soon as the conversation mentions Springfield
(rather than Smyrna), you are fairly sure that the
Simpsons television series (rather than Greek poetry)
is the subject.
On the other hand, if everyone had a \textit{unique} name,
then there would be no possibility of confusing 20th century
American cartoon characters with ancient Greek poets.


% where SSA is applied, in compiler intermediate representations...
This book is about the \textit{static single assignment form} (SSA),
which is a naming convention for variables in low-level representations
of computer programs.
A program is said to be in SSA form when each variable is defined (hence
\textit{assignment})
exactly once (hence \textit{single}) in the program text
(hence \textit{static}).

While humans can write code in SSA (examples), this is not necessary
since it is straightforward to translate a non-SSA program into an SSA
program. (Links to appropriate chapters here?)

Why is it important for compilers to have SSA-based IRs? Simple motivation
here, then link to appropriate chapters later in book.



%%%%%%%%%%%

\section{informal semantics (with examples)}

\textbf{3 pages}

Given a simple pseudo-code language, show examples of programs in SSA.
(Should I show before/after SSA transformation, or just programs
in SSA form already?)

example 1. Straightline code. (sequence)

\begin{verbatim}
x = 1;
y = 2;
x = x+y;
\end{verbatim}

example 2. if/then/else conditional.  (selection)

\begin{verbatim}
x = input();
if (x == 42)
  y = 1;
else
  y = x*2;
print(y)
\end{verbatim}

(Explain carefully how $\phi$-functions work.) 
Semantics of phi. -at control-flow merge points.
Talk about executable extensions of phi fns - gamma fns etc - 
forward refs?

example 3. while loop? (iteration)

\begin{verbatim}
x = 0;
y = 0;
while (x< 10) {
  y = y + x;
  x++;
}
print(y)
\end{verbatim}

%%%%%%%%%%%

\section{definition}

\textbf{1.5 pages}

Informally, static means `program text.'
single means `unique names'
assignment means `at variable definitions.'

Again, informally, unique definition for each variable.

Formally, in terms of dominance. Each var has a unique
definition, and def dominates all uses.
Perhaps require implicit defs of all vars at entry,
implicit uses of all vars at exit?

Probably need forward links to Philip's discussion of
SSA flavours and properties here.

%%%%%%%%%%%

\section{brief history}

\textbf{1.5 pages}

Crib most of this from Kenneth Zadeck. 
Talk about early developments at IBM in 1980s.
Talk about eventual emergence of SSA.
Talk about other program dependence graph
representations, perhaps a forward pointer to 
VSDG chapter.


%%%%%%%%%%%

\section{comparison with dataflow analysis (high level overview of DFA)}

\textbf{3 pages}

Very simple. Discuss lattice-based data flow analysis.
Propagating facts around control-flow points in a CFG.

Talk about SSA simplification - rename whenever data flow
facts can change (for a certain class of data flow problems?)
so, can associate facts directly with names, rather than with
name at point.


%%%%%%%%%%%
