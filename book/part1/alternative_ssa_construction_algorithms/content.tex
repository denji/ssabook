\chapter{Alternative SSA construction/destruction algorithms
   \Author{Sreedhar/Das/Ramakrishna
                   and F. Rastello}}
\numberofpages{18}

\section{Advanced SSA construction Algorithms}
\label{sec:advanced_construction}
\textbf{13 pages}

Assumes that DJ graph and APT 
descriptions are put in Appendix.

(a) 4 pages for Sreedhar-Gao: written by Sreedhar

(b) 2 pages for Pingali-Bilardi: written by Sreedhar

(c) 3 pages for Ramalingam and Cytron-Ferrante-93 (both of which I think
should be mentioned). Choi (I am not sure if this needs to be mentioned):
written by Sreedhar/Das-Ramakrishna

(d) 2 pages for Das-Ramakrishna.

(e) 1 pages for the directions of phi-placement: similar to conclusion
section of Bilardi-Pingali-JACM, and conclusion.

(f) 1 page for buffer?


\section{SSA destruction for machine code \Author{F. Rastello}}
\label{sec:advanced_destruction}
\textbf{5 pages}
Describes the context: cannot necessarily split critical edges, some variables have renaming constraints, some instructions have renaming constraints that we want to handle during SSA destruction (some may be handled during register allocation). 

Renaming constraints are handled using copies around constrained instructions. Go to conventional-SSA using Sreedhar's~I technique. Outline the limitation of this technique when dealing with condional jump instruction that define a variable itself; when dealing with renaming constraints for variables that interfere...

Define our ``ultimate'' notion of interference using value. Build the interference graph (provide the simplified pseudo-code). Do coalescing. Refer to CGO'09 paper for issues concerning JIT compilation. Remove $\phi$-functions and perform renaming. Provide a more sophisticated pseudo-code (than for \ref{sec:classical_destruction}) for parallel copies sequentialisation (that can be performed before or after coalescing and $\phi$ removal.

