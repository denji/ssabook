   1- It is not clear which variables must be included in v.defs. It would be interesting to run at least "algorithm 8" on the representation in figure 5.1(b). This should show that v==x0 and that x0.def contains two variables x0.1 and x0.2, for the original definition of x0 and the inserted one. Then it should show how the insertion of the PHI instruction triggers the renaming of the use of x0 in the last block. What is not clear to me is what will happen if the renaming of x0 into x2 must generate another PHI, for example PHI (x0,x2), lower in the graph, because the IDF has changed. For me, this implies that x2 is added into v.defs, but I do not see such update.

    2- I would like to have an idea on how the loop "for each use (u, index)" is best implemented. Is it necessary to build a list x.use for each SSA variable x in the program prior to run the algorithm ? Or is it reasonable to implement it as a traversal of all the instructions in all the nodes dominated by a definition ?

    3- It would be interesting to explain how far a very local modification, such has in 5.1(b), can generate new PHI instructions and require variable renaming. With such an example, it should be mentioned that for loop transformations a loop closed form allows to limit to a loop region the impact of a transformation. 
