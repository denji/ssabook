\chapter{SSA destruction for machine code \Author{F. Rastello}}
\inputprogress
\graphicspath{{figs/}{part1/alternative_ssa_destruction_algorithm/figs/}{../part1/alternative_ssa_destruction_algorithm/figs/}}
\inputpath{{.}{part1/alternative_ssa_destruction_algorithm/}{../part1/alternative_ssa_destruction_algorithm/}}

\label{chap:alternative_ssa_destruction_algorithm}
\index{interference}
\index{ssa destruction}


\input{introduction}
\input{machine_level_constraints}
\input{code_quality}
\input{speed_memory_footprint}
\input{further_readings}

\section{Notes (to be removed)}

Define our ``ultimate'' notion of interference using value. Build the interference graph (provide the simplified pseudo-code). Do coalescing. Refer to CGO'09 paper for issues concerning JIT compilation. Remove \phifuns and perform renaming. Provide a more sophisticated pseudo-code (than for \ref{sec:classical_destruction}) for parallel copies sequentialisation (that can be performed before or after coalescing and $\phi$ removal.




