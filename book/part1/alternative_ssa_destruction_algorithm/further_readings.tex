 \section{Further Readings}
SSA destruction was first addressed by Cytron et al.~\cite{CFR+91} who propose to simply replace each \phifun by copies in the predecessor basic-block. Although this naive translation seems, at first sight, correct, Briggs et
al.~\cite{BriggsSSA} pointed subtle errors due to parallel copies and/or
critical edges in the control-flow graph. Two typical situations are
identified, namely the ``lost copy problem'' and the ``swap problem''.
The first solution, both simple and correct, was proposed by Sreedhar et al.~\cite{VC+99}. They address the associated problem of coalescing and describe three solutions. 
The first one, consists in three
steps: a) translate SSA into CSSA, by isolating \phifuns; b)
eliminate redundant copies; c) eliminate \phifuns and leave CSSA.
The third solution that turns out to be nothing else than the first solution that would virtualizes the isolation of \phifuns shows to introduce less copies. The reason for that, identified by Boissinot et al., is due to the fact that in the presence of many copies the code contains many intersecting variables that do not actually interfere. Boissinot et al.~\cite{Boissinot09} revisited Sreedhar et al.'s approach in the light of this remark and proposed the value based interference described in this chapter.

The ultimate notion of interference was discussed by Chaitin et al.~\cite{Chaitin81} in the context of register allocation. 
They proposed a simple conservative test: \emph{two variables interfere if
  one is live at a definition point of the other and this definition is not a
  copy between the two variables}. This interference notion is the most
commonly used, see for example how the interference graph is computed
in~\cite{appel:2002:modern}. Still they noticed that, with this conservative interference definition,
after coalescing some variables the interference graph has to be updated or rebuilt. 
A counting mechanism to update the interference graph was proposed,  but it was considered to be
too space consuming. Recomputing it from time to time was preferred~\cite{Chaitin81,Chaitin82}.

The value based technique described here can also obviously be used in the context of register allocation even if the code is not under SSA form. The notion of value may be approximated using data-flow analysis on specific lattices~\cite{AlpernWZ88} and under SSA form simple global value numbering~\cite{Rosen88} can be used.

Leung and George~\cite{leung:1999:ssa_mach} addressed SSA destruction for machine code.
Register renaming constraints, such as calling conventions or dedicated registers, are treated with pinned variables.
Simple data-flow analysis scheme is used to place repairing copies.
By revisiting this approach to address the coalescing of copies Rastello et al.~\cite{Rastello:2004:CGO} pointed out and fixed a few errors present in the original algorithm. While being very efficient in minimizing the introduced copies, this algorithm is quite complicated to implement and not suited for just in time compilation.

The first technique to address speed and memory footprint was proposed by Budimli\'{c} et al.~\cite{Budimlic02}. 
It proposes the de-coalescing technique, revisited in this chapter, that exploits the underlying tree structure of dominance relation between variables of the same merged-set.

Last, this chapter describes a fast sequentialization algorithm that requires the minimum number of copies.
A similar algorithm has already been proposed by C. May~\cite{May89}.

