\applynumberofpages\chapter{Classical construction/update/destruction algorithm \Author{J. Singer, F. Rastello}}
\numberofpages{8}

\section{Simple programming language model}
\textbf{1 page}

Simple description of an intraprocedural control flow graph
representation, with non-address-taken local variables.
Forward references to sections dealing with more SSA for complex
features like memory, concurrency, etc.
No constraints on control-flow structures in CFG
(unlike in syntax-directed SSA construction algorithms).


\section{Construction}
\textbf{2-3 pages}
TOPLAS 91 (not simplest, but gets ready for repair/maintain section).
Split algorithm into $\phi$-function placement, and variable
renaming. For $\phi$-fn placement, use dominance frontiers.
(Refer to appendix for dominance?) 
For variable renaming, use simple stack-based algorithm.
Use a running example CFG throughout the transformation process.
Probably construct minimal SSA form.

\section{Destruction \Author{F. Rastello}}
\label{sec:classical_destruction}
\textbf{2-3 pages}

The simplest way is to split critical edges and replace $\phi$-fonctions by parallel copies on predecessor blocks (no coalescing). Provide a ``W'' example with a back-edge (parallel copies and edge splitting is required). Outline that this technique may not work for machine code, do not perform coalescing, and is not optimized for speed. Refer to the advanced technique described in \ref{sec:advanced_destruction}. Provide a simple but not optimal pseudo code for parallel copy sequentialization. Provide the pseudo-code for $\phi$-function replacement.

\section{Turning general SSA into conventional/pruned/dominance property}
\textbf{2 pages}

Discussion regarding relationship between minimal and pruned SSA, etc.
$phi$-function removal can give pruned SSA but break
dominance properties, etc. Keep this section simple, and don't duplicate
material from Philip Brisk in previous chapter.
Ask Philip who may have some materials for the ``turning into SSA with dominance property'' part.

