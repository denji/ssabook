\chapter*{classical construction algorithm}

\chapterauthor{Singer (unless someone else volunteers)}

\TODO{very very readable}

\textbf{total page count for chapter: 12 pages}

\section{for simple programming language model}
\textbf{1 page}

Simple description of an intraprocedural control flow graph
representation, with non-address-taken local variables.
Forward references to sections dealing with more SSA for complex
features like memory, concurrency, etc.
No constraints on control-flow structures in CFG
(unlike in syntax-directed SSA construction algorithms).


\section{toplas 91 (not simplest, but gets ready for repair/maintain section)}
\textbf{6 pages}

Split algorithm into $\phi$-function placement, and variable
renaming. For $\phi$-fn placement, use dominance frontiers.
(Refer to appendix for dominance?) 
For variable renaming, use simple stack-based algorithm.
Use a running example CFG throughout the transformation process.
Probably construct minimal SSA form.

\section{destruction}
\textbf{3 pages}

\textbf{Fabrice Rastello} to advise on this section. (He is writing
the advanced destruction section in the next chapter.)

\section{turning general SSA into conventional/pruned/dominance property}
\textbf{2 pages}

Discussion regarding relationship between minimal and pruned SSA, etc.
$phi$-function removal can give pruned SSA but break
dominance properties, etc. Keep this section simple, and don't duplicate
material from Philip Brisk in previous chapter.


